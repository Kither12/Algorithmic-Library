{
	"Main": {
		"prefix": "kith",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "const int INF = 1e9 + 7;",
		  "const int MOD = 1e9 + 7;",
		  "const double EPS = 1e-9;",
		  "#define all(X) X.begin(), X.end()",
		  "#define rall(X) X.rbegin(), X.rend()",
		  "",
		  "void Solve(){",
		  "",
		  "}",
		  "int main(){",
		  "    ios_base::sync_with_stdio(false);",
		  "    cin.tie(0); cout.tie(0);",
		  "",
		  "    int q = 1;",
		  "    cin >> q;",
		  "    while (q--)",
		  "    {",
		  "        Solve();",
		  "    }",
		  "",
		  "    return 0;",
		  "}"
		],
		"description": "Main"
	  },
	  "Matrix": {
		"prefix": "Matrix",
		"body": [
		  "template<typename T>",
		  "struct Matrix {",
		  "    int n_row, n_col;",
		  "    vector<T> x;",
		  "",
		  "    // accessors",
		  "    typename vector<T>::iterator operator [] (int r) {",
		  "        return x.begin() + r * n_col;",
		  "    }",
		  "    inline T get(int i, int j) const { return x[i * n_col + j]; }",
		  "    vector<T> at(int r) const {",
		  "        return vector<T> { x.begin() + r * n_col, x.begin() + (r+1) * n_col };",
		  "    }",
		  "",
		  "    // constructors",
		  "    Matrix() = default;",
		  "    Matrix(int _n_row, int _n_col) : n_row(_n_row), n_col(_n_col), x(n_row * n_col) {}",
		  "    Matrix(const vector<vector<T>>& d) : n_row(d.size()), n_col(d.size() ? d[0].size() : 0) {",
		  "        for (auto& row : d) std::copy(row.begin(), row.end(), std::back_inserter(x));",
		  "    }",
		  "",
		  "    // convert to 2d vec",
		  "    vector<vector<T>> vecvec() const {",
		  "        vector<vector<T>> ret(n_row);",
		  "        for (int i = 0; i < n_row; i++) {",
		  "            std::copy(x.begin() + i*n_col,",
		  "                    x.begin() + (i+1)*n_col,",
		  "                    std::back_inserter(ret[i]));",
		  "        }",
		  "        return ret;",
		  "    }",
		  "    operator vector<vector<T>>() const { return vecvec(); }",
		  "",
		  "    static Matrix identity(int n) {",
		  "        Matrix res(n, n);",
		  "        for (int i = 0; i < n; i++) {",
		  "            res[i][i] = 1;",
		  "        }",
		  "        return res;",
		  "    }",
		  "",
		  "    Matrix transpose() const {",
		  "        Matrix res(n_col, n_row);",
		  "        for (int i = 0; i < n_row; i++) {",
		  "            for (int j = 0; j < n_col; j++) {",
		  "                res[j][i] = this->get(i, j);",
		  "            }",
		  "        }",
		  "        return res;",
		  "    }",
		  "",
		  "    Matrix& operator *= (const Matrix& r) { return *this = *this * r; }",
		  "    Matrix operator * (const Matrix& r) const {",
		  "        assert(n_col == r.n_row);",
		  "        Matrix res(n_row, r.n_col);",
		  "",
		  "        for (int i = 0; i < n_row; i++) {",
		  "            for (int k = 0; k < n_col; k++) {",
		  "                for (int j = 0; j < r.n_col; j++) {",
		  "                    res[i][j] += this->get(i, k) * r.get(k, j);",
		  "                }",
		  "            }",
		  "        }",
		  "        return res;",
		  "    }",
		  "",
		  "    Matrix pow(long long n) const {",
		  "        assert(n_row == n_col);",
		  "        Matrix res = identity(n_row);",
		  "        if (n == 0) return res;",
		  "",
		  "        bool res_is_id = true;",
		  "        for (int i = 63 - __builtin_clzll(n); i >= 0; i--) {",
		  "            if (!res_is_id) res *= res;",
		  "            if ((n >> i) & 1) res *= (*this), res_is_id = false;",
		  "        }",
		  "        return res;",
		  "    }",
		  "",
		  "    // Gauss",
		  "    template <typename T2, typename std::enable_if<std::is_floating_point<T2>::value>::type * = nullptr>",
		  "    static int choose_pivot(const Matrix<T2> &mtr, int h, int c) noexcept {",
		  "        int piv = -1;",
		  "        for (int j = h; j < mtr.n_row; j++) {",
		  "            if (mtr.get(j, c) and (piv < 0 or std::abs(mtr.get(j, c)) > std::abs(mtr.get(piv, c)))) piv = j;",
		  "        }",
		  "        return piv;",
		  "    }",
		  "    template <typename T2, typename std::enable_if<!std::is_floating_point<T2>::value>::type * = nullptr>",
		  "    static int choose_pivot(const Matrix<T2> &mtr, int h, int c) noexcept {",
		  "        for (int j = h; j < mtr.n_row; j++) {",
		  "            if (mtr.get(j, c) != T(0)) return j;",
		  "        }",
		  "        return -1;",
		  "    }",
		  "",
		  "    // return upper triangle matrix",
		  "    [[nodiscard]] Matrix gauss() const {",
		  "        int c = 0;",
		  "        Matrix mtr(*this);",
		  "        vector<int> ws;",
		  "        ws.reserve(n_col);",
		  "",
		  "        for (int h = 0; h < n_row; h++) {",
		  "            if (c == n_col) break;",
		  "            int piv = choose_pivot(mtr, h, c);",
		  "            if (piv == -1) {",
		  "                c++;",
		  "                h--;",
		  "                continue;",
		  "            }",
		  "            if (h != piv) {",
		  "                for (int w = 0; w < n_col; w++) {",
		  "                    swap(mtr[piv][w], mtr[h][w]);",
		  "                    mtr[piv][w] *= -1; // for determinant",
		  "                }",
		  "            }",
		  "            ws.clear();",
		  "            for (int w = c; w < n_col; w++) {",
		  "                if (mtr[h][w] != 0) ws.emplace_back(w);",
		  "            }",
		  "            const T hcinv = T(1) / mtr[h][c];",
		  "            for (int hh = 0; hh < n_row; hh++) {",
		  "                if (hh != h) {",
		  "                    const T coeff = mtr[hh][c] * hcinv;",
		  "                    for (auto w : ws) mtr[hh][w] -= mtr[h][w] * coeff;",
		  "                    mtr[hh][c] = 0;",
		  "                }",
		  "            }",
		  "            c++;",
		  "        }",
		  "        return mtr;",
		  "    }",
		  "",
		  "    // For upper triangle matrix",
		  "    T det() const {",
		  "        T ret = 1;",
		  "        for (int i = 0; i < n_row; i++) {",
		  "            ret *= get(i, i);",
		  "        }",
		  "        return ret;",
		  "    }",
		  "",
		  "    // return rank of inverse matrix. If rank < n -> not invertible",
		  "    int inverse() {",
		  "        assert(n_row == n_col);",
		  "        vector<vector<T>> ret = identity(n_row), tmp = *this;",
		  "        int rank = 0;",
		  "",
		  "        for (int i = 0; i < n_row; i++) {",
		  "            int ti = i;",
		  "            while (ti < n_row && tmp[ti][i] == 0) ++ti;",
		  "            if (ti == n_row) continue;",
		  "            else ++rank;",
		  "",
		  "            ret[i].swap(ret[ti]);",
		  "            tmp[i].swap(tmp[ti]);",
		  "",
		  "            T inv = T(1) / tmp[i][i];",
		  "            for (int j = 0; j < n_col; j++) ret[i][j] *= inv;",
		  "            for (int j = i+1; j < n_col; j++) tmp[i][j] *= inv;",
		  "",
		  "            for (int h = 0; h < n_row; h++) {",
		  "                if (i == h) continue;",
		  "                const T c = -tmp[h][i];",
		  "                for (int j = 0; j < n_col; j++) ret[h][j] += ret[i][j] * c;",
		  "                for (int j = i+1; j < n_col; j++) tmp[h][j] += tmp[i][j] * c;",
		  "            }",
		  "        }",
		  "",
		  "        *this = ret;",
		  "        return rank;",
		  "    }",
		  "",
		  "    // sum of all elements in this matrix",
		  "    T sum_all() {",
		  "        return submatrix_sum(0, 0, n_row, n_col);",
		  "    }",
		  "",
		  "    // sum of [r1, r2) x [c1, c2)",
		  "    T submatrix_sum(int r1, int c1, int r2, int c2) {",
		  "        T res {0};",
		  "        for (int r = r1; r < r2; ++r) {",
		  "            res += std::accumulate(",
		  "                    x.begin() + r * n_col + c1,",
		  "                    x.begin() + r * n_col + c2,",
		  "                    T{0});",
		  "        }",
		  "        return res;",
		  "    }",
		  "};",
		  ""
		],
		"description": "Matrix"
	  },
	  "Mint": {
		"prefix": "Mint",
		"body": [
		  "template <typename T>",
		  "T inverse(T a, T m) {",
		  "  T u = 0, v = 1;",
		  "  while (a != 0) {",
		  "    T t = m / a;",
		  "    m -= t * a; swap(a, m);",
		  "    u -= t * v; swap(u, v);",
		  "  }",
		  "  assert(m == 1);",
		  "  return u;",
		  "}",
		  "",
		  "template <typename T>",
		  "class Modular {",
		  " public:",
		  "  using Type = typename decay<decltype(T::value)>::type;",
		  "",
		  "  constexpr Modular() : value() {}",
		  "  template <typename U>",
		  "  Modular(const U& x) {",
		  "    value = normalize(x);",
		  "  }",
		  "",
		  "  template <typename U>",
		  "  static Type normalize(const U& x) {",
		  "    Type v;",
		  "    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);",
		  "    else v = static_cast<Type>(x % mod());",
		  "    if (v < 0) v += mod();",
		  "    return v;",
		  "  }",
		  "",
		  "  const Type& operator()() const { return value; }",
		  "  template <typename U>",
		  "  explicit operator U() const { return static_cast<U>(value); }",
		  "  constexpr static Type mod() { return T::value; }",
		  "",
		  "  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }",
		  "  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }",
		  "  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }",
		  "  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }",
		  "  Modular& operator++() { return *this += 1; }",
		  "  Modular& operator--() { return *this -= 1; }",
		  "  Modular operator++(int) { Modular result(*this); *this += 1; return result; }",
		  "  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }",
		  "  Modular operator-() const { return Modular(-value); }",
		  "",
		  "  template <typename U = T>",
		  "  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {",
		  "    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
		  "    return *this;",
		  "  }",
		  "  template <typename U = T>",
		  "  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {",
		  "    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());",
		  "    value = normalize(value * rhs.value - q * mod());",
		  "    return *this;",
		  "  }",
		  "  template <typename U = T>",
		  "  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {",
		  "    value = normalize(value * rhs.value);",
		  "    return *this;",
		  "  }",
		  "",
		  "  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }",
		  "",
		  "  friend const Type& abs(const Modular& x) { return x.value; }",
		  "",
		  "  template <typename U>",
		  "  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);",
		  "",
		  "  template <typename U>",
		  "  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);",
		  "",
		  "  template <typename V, typename U>",
		  "  friend V& operator>>(V& stream, Modular<U>& number);",
		  "",
		  " private:",
		  "  Type value;",
		  "};",
		  "",
		  "template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }",
		  "template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }",
		  "template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }",
		  "",
		  "template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
		  "template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }",
		  "template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
		  "",
		  "template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }",
		  "",
		  "template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
		  "template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
		  "template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
		  "",
		  "template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
		  "template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
		  "template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
		  "",
		  "template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
		  "template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
		  "template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
		  "",
		  "template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
		  "template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
		  "template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
		  "",
		  "template<typename T, typename U>",
		  "Modular<T> power(const Modular<T>& a, const U& b) {",
		  "  assert(b >= 0);",
		  "  Modular<T> x = a, res = 1;",
		  "  U p = b;",
		  "  while (p > 0) {",
		  "    if (p & 1) res *= x;",
		  "    x *= x;",
		  "    p >>= 1;",
		  "  }",
		  "  return res;",
		  "}",
		  "",
		  "template <typename T>",
		  "bool IsZero(const Modular<T>& number) {",
		  "  return number() == 0;",
		  "}",
		  "",
		  "template <typename T>",
		  "string to_string(const Modular<T>& number) {",
		  "  return to_string(number());",
		  "}",
		  "",
		  "// U == std::ostream? but done this way because of fastoutput",
		  "template <typename U, typename T>",
		  "U& operator<<(U& stream, const Modular<T>& number) {",
		  "  return stream << number();",
		  "}",
		  "",
		  "// U == std::istream? but done this way because of fastinput",
		  "template <typename U, typename T>",
		  "U& operator>>(U& stream, Modular<T>& number) {",
		  "  typename common_type<typename Modular<T>::Type, long long>::type x;",
		  "  stream >> x;",
		  "  number.value = Modular<T>::normalize(x);",
		  "  return stream;",
		  "}",
		  "",
		  "/*",
		  "using ModType = int;",
		  "",
		  "struct VarMod { static ModType value; };",
		  "ModType VarMod::value;",
		  "ModType& md = VarMod::value;",
		  "using Mint = Modular<VarMod>;",
		  "*/",
		  "",
		  "constexpr int md = 998244353;",
		  "using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;",
		  "",
		  "vector<Mint> fact;",
		  "vector<Mint> inv_fact;",
		  " ",
		  "Mint C(int n, int k) {",
		  "  if (k < 0 || k > n) {",
		  "    return 0;",
		  "  }",
		  "  while ((int) fact.size() < n + 1) {",
		  "    if (fact.empty()) {",
		  "      fact = inv_fact = {1};",
		  "      continue;",
		  "    }",
		  "    fact.push_back(fact.back() * (int) fact.size());",
		  "    inv_fact.push_back(1 / fact.back());",
		  "  }",
		  "  return fact[n] * inv_fact[k] * inv_fact[n - k];",
		  "}"
		],
		"description": "Mint"
	  },
	  "RMQ": {
		"prefix": "RMQ",
		"body": [
		  "// RMQ {{{",
		  "//",
		  "// Sparse table",
		  "// Usage:",
		  "// RMQ<int, _min> st(v);",
		  "//",
		  "// Note:",
		  "// - doesn't work for empty range",
		  "//",
		  "// Tested:",
		  "// - https://judge.yosupo.jp/problem/staticrmq",
		  "template<class T, T (*op) (T, T)> struct RMQ {",
		  "    RMQ() = default;",
		  "    RMQ(const vector<T>& v) : t{v}, n{(int) v.size()} {",
		  "        for (int k = 1; (1<<k) <= n; ++k) {",
		  "            t.emplace_back(n - (1<<k) + 1);",
		  "            for (int i = 0; i + (1<<k) <= n; ++i) {",
		  "                t[k][i] = op(t[k-1][i], t[k-1][i + (1<<(k-1))]);",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    // get range [l, r]",
		  "    // doesn't work for empty range",
		  "    T get(int l, int r) const {",
		  "        r += 1;",
		  "        assert(0 <= l && l < r && r <= n);",
		  "        int k = __lg(r - l);",
		  "        return op(t[k][l], t[k][r - (1<<k)]);",
		  "    }",
		  "",
		  "private:",
		  "    vector<vector<T>> t;",
		  "    int n;",
		  "};",
		  "template<class T> T _min(T a, T b) { return b < a ? b : a; }",
		  "template<class T> T _max(T a, T b) { return a < b ? b : a; }",
		  "template<class T> T _gcd(T a, T b) { return __gcd(a, b); }"
		],
		"description": "RMQ"
	  },
	  "LCA": {
		"prefix": "LCA",
		"body": [
		  "struct Tree_t {",
		  "    vector<int> events;",
		  "    vector<int> sta;",
		  "    vector<int> lev;",
		  "    vector<int> tin;",
		  "    vector<int> tou;",
		  "    vector<int> idx;",
		  "    vector<vector<int>> par;",
		  "    int timer;",
		  "    vector<vector<int>> f;",
		  "    vector<int> mlg;",
		  "",
		  "    void dfs(int u, int p, const vector<vector<int>>& adj) {",
		  "        idx[tin[u] = timer++] = u;",
		  "        sta[u] = events.size();",
		  "        events.push_back(tin[u]);",
		  "        for (int i = 1; i < (int) par.size(); i++) {",
		  "            par[i][u] = par[i - 1][par[i - 1][u]];",
		  "        }",
		  "        for (int i = 0; i < adj[u].size(); i++) {",
		  "            int v = adj[u][i];",
		  "            if (v != p) {",
		  "                lev[v] = lev[u] + 1;",
		  "                par[0][v] = u;",
		  "                dfs(v, u, adj);",
		  "                events.push_back(tin[u]);",
		  "            }",
		  "        }",
		  "        tou[u] = timer - 1;",
		  "    }",
		  "    void build(const vector<vector<int>>& adj, int rt = 0) {",
		  "        events.clear();",
		  "        sta.resize(adj.size());",
		  "        lev.resize(adj.size());",
		  "        tin.resize(adj.size());",
		  "        tou.resize(adj.size());",
		  "        idx.resize(adj.size());",
		  "        par.resize(__lg(adj.size()) + 1);",
		  "        for (int i = 0; i < (int) par.size(); i++) {",
		  "            par[i].resize(adj.size());",
		  "            par[i][rt] = rt;",
		  "        }",
		  "        timer = lev[rt] = 0, dfs(rt, -1, adj);",
		  "        int logn = __lg(events.size()) + 1;",
		  "        f.resize(logn);",
		  "        for (int i = 0; i < logn; i++) {",
		  "            f[i].resize(events.size());",
		  "        }",
		  "        for (int i = 0; i < events.size(); i++) {",
		  "            f[0][i] = events[i];",
		  "        }",
		  "        for (int i = 1; i < logn; i++) {",
		  "            for (int j = 0; j + (1 << i - 1) < events.size(); j++) {",
		  "                f[i][j] = min(f[i - 1][j], f[i - 1][j + (1 << i - 1)]);",
		  "            }",
		  "        }",
		  "        mlg.resize(events.size());",
		  "        for (int i = 1; i < mlg.size(); i++) {",
		  "            mlg[i] = __lg(i);",
		  "        }",
		  "    }",
		  "    int rmq(int u, int v) {",
		  "        int l = u == v ? 0 : mlg[v - u];",
		  "        return min(f[l][u], f[l][v - (1 << l) + 1]);",
		  "    }",
		  "    int lca(int u, int v) {",
		  "        if (sta[u] > sta[v]) swap(u, v);",
		  "        return idx[rmq(sta[u], sta[v])];",
		  "    }",
		  "    int dist(int u, int v) {",
		  "        int a = lca(u, v);",
		  "        return lev[u] + lev[v] - lev[a] - lev[a];",
		  "    }",
		  "    int isanc(int p, int u) {",
		  "        return tin[p] <= tin[u] && tou[u] <= tou[p];",
		  "    }",
		  "    int go_up(int u, int k) {",
		  "        for (int i = (int) par.size() - 1; 0 <= i; i--) {",
		  "            if ((1 << i) <= k) {",
		  "                k -= 1 << i;",
		  "                u = par[i][u];",
		  "            }",
		  "        }",
		  "        return u;",
		  "    }",
		  "    int go_to(int u, int v, int k) {",
		  "        int a = lca(u, v);",
		  "        if (k <= lev[u] - lev[a]) {",
		  "            return go_up(u, k);",
		  "        }",
		  "        k -= lev[u] - lev[a];",
		  "        k = lev[v] - lev[a] - k;",
		  "        return go_up(v, k);",
		  "    }",
		  "};"
		],
		"description": "LCA"
	  },
	  "Sieve": {
		"prefix": "Sieve",
		"body": [
		  "struct Sieve{",
		  "    int N = 1e7;",
		  "    vector<int> minFactor;",
		  "    vector<int> prime;",
		  "",
		  "    Sieve(){",
		  "        minFactor = vector<int>(N + 5);",
		  "        Compute();",
		  " }",
		  "    void Compute(){",
		  "        for(int i=2; i <= N; ++i){",
		  "            if (minFactor[i] == 0) {",
		  "                minFactor[i] = i;",
		  "                prime.push_back(i);",
		  "            }",
		  "            for (int j=0; j < (int)prime.size() && prime[j] <= minFactor[i] && i*prime[j] <= N; ++j) {",
		  "                minFactor[i * prime[j]] = prime[j];",
		  "            }",
		  "        }",
		  "    }",
		  "    vector<int> factorize(int n) {",
		  "        vector<int> res;",
		  "        while (n != 1) {",
		  "            res.push_back(minFactor[n]);",
		  "               int temp = minFactor[n];",
		  "               while(n % temp == 0) n /= temp;",
		  "        }",
		  "        return res;",
		  "    }",
		  "};"
		],
		"description": "Sieve"
	  },
	  "EulerTotient": {
		"prefix": "EulerTotient",
		"body": [
		  "long long eulerPhi(long long n) { // = n (1-1/p1) ... (1-1/pn)",
		  "    if (n == 0) return 0;",
		  "    long long ans = n;",
		  "    for (int x = 2; x*x <= n; ++x) {",
		  "        if (n % x == 0) {",
		  "            ans -= ans / x;",
		  "            while (n % x == 0) n /= x;",
		  "        }",
		  "    }",
		  "    if (n > 1) ans -= ans / n;",
		  "    return ans;",
		  "}",
		  "",
		  "vector<int> phi_n(int n) {",
		  "    vector<int> phi(n + 1);",
		  "    for (int i = 0; i <= n; i++)",
		  "        phi[i] = i;",
		  "",
		  "    for (int i = 2; i <= n; i++) {",
		  "        if (phi[i] == i) {",
		  "            for (int j = i; j <= n; j += i)",
		  "                phi[j] -= phi[j] / i;",
		  "        }",
		  "    }",
		  "    return phi;",
		  "}"
		],
		"description": "EulerTotient"
	  },
	  "Rabin Miller": {
		"prefix": "Rabin",
		"body": [
		  "inline uint64_t mod_mult64(uint64_t a, uint64_t b, uint64_t m) {",
		  "    return __int128_t(a) * b % m;",
		  "}",
		  "uint64_t mod_pow64(uint64_t a, uint64_t b, uint64_t m) {",
		  "    uint64_t ret = (m > 1);",
		  "    for (;;) {",
		  "        if (b & 1) ret = mod_mult64(ret, a, m);",
		  "        if (!(b >>= 1)) return ret;",
		  "        a = mod_mult64(a, a, m);",
		  "    }",
		  "}",
		  "",
		  "// Works for all primes p < 2^64",
		  "bool is_prime(uint64_t n) {",
		  "    if (n <= 3) return (n >= 2);",
		  "    static const uint64_t small[] = {",
		  "        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,",
		  "        71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139,",
		  "        149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,",
		  "    };",
		  "    for (size_t i = 0; i < sizeof(small) / sizeof(uint64_t); ++i) {",
		  "        if (n % small[i] == 0) return n == small[i];",
		  "    }",
		  "",
		  "    // Makes use of the known bounds for Miller-Rabin pseudoprimes.",
		  "    static const uint64_t millerrabin[] = {",
		  "        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,",
		  "    };",
		  "    static const uint64_t A014233[] = {  // From OEIS.",
		  "        2047LL, 1373653LL, 25326001LL, 3215031751LL, 2152302898747LL,",
		  "        3474749660383LL, 341550071728321LL, 341550071728321LL,",
		  "        3825123056546413051LL, 3825123056546413051LL, 3825123056546413051LL, 0,",
		  "    };",
		  "    uint64_t s = n-1, r = 0;",
		  "    while (s % 2 == 0) {",
		  "        s /= 2;",
		  "        r++;",
		  "    }",
		  "    for (size_t i = 0, j; i < sizeof(millerrabin) / sizeof(uint64_t); i++) {",
		  "        uint64_t md = mod_pow64(millerrabin[i], s, n);",
		  "        if (md != 1) {",
		  "            for (j = 1; j < r; j++) {",
		  "                if (md == n-1) break;",
		  "                md = mod_mult64(md, md, n);",
		  "            }",
		  "            if (md != n-1) return false;",
		  "        }",
		  "        if (n < A014233[i]) return true;",
		  "    }",
		  "    return true;",
		  "}"
		],
		"description": "Rabin Miller"
	  },
	  "Pollard Rho": {
		"prefix": "Pollard",
		"body": [
		  "using ll = long long;",
		  "using ull = unsigned long long;",
		  "using ld = long double;",
		  "ll mult(ll x, ll y, ll md) {",
		  "    ull q = (ld)x * y / md;",
		  "    ll res = ((ull)x * y - q * md);",
		  "    if (res >= md) res -= md;",
		  "    if (res < 0) res += md;",
		  "    return res;",
		  "}",
		  "",
		  "ll powMod(ll x, ll p, ll md) {",
		  "    if (p == 0) return 1;",
		  "    if (p & 1) return mult(x, powMod(x, p - 1, md), md);",
		  "    return powMod(mult(x, x, md), p / 2, md);",
		  "}",
		  "",
		  "bool checkMillerRabin(ll x, ll md, ll s, int k) {",
		  "    x = powMod(x, s, md);",
		  "    if (x == 1) return true;",
		  "    while(k--) {",
		  "        if (x == md - 1) return true;",
		  "        x = mult(x, x, md);",
		  "        if (x == 1) return false;",
		  "    }",
		  "    return false;",
		  "}",
		  "bool isPrime(ll x) {",
		  "    if (x == 2 || x == 3 || x == 5 || x == 7) return true;",
		  "    if (x % 2 == 0 || x % 3 == 0 || x % 5 == 0 || x % 7 == 0) return false;",
		  "    if (x < 121) return x > 1;",
		  "    ll s = x - 1;",
		  "    int k = 0;",
		  "    while(s % 2 == 0) {",
		  "        s >>= 1;",
		  "        k++;",
		  "    }",
		  "    if (x < 1LL << 32) {",
		  "        for (ll z : {2, 7, 61}) {",
		  "            if (!checkMillerRabin(z, x, s, k)) return false;",
		  "        }",
		  "    } else {",
		  "        for (ll z : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {",
		  "            if (!checkMillerRabin(z, x, s, k)) return false;",
		  "        }",
		  "    }",
		  "    return true;",
		  "}",
		  "",
		  "ll gcd(ll x, ll y) {",
		  "    return y == 0 ? x : gcd(y, x % y);",
		  "}",
		  "",
		  "void pollard(ll x, vector<ll> &ans) {",
		  "    if (isPrime(x)) {",
		  "        ans.push_back(x);",
		  "        return;",
		  "    }",
		  "    ll c = 1;",
		  "    while(true) {",
		  "        c = 1 + get_rand(x - 1);",
		  "        auto f = [&](ll y) {",
		  "            ll res = mult(y, y, x) + c;",
		  "            if (res >= x) res -= x;",
		  "            return res;",
		  "        };",
		  "        ll y = 2;",
		  "        int B = 100;",
		  "        int len = 1;",
		  "        ll g = 1;",
		  "        while(g == 1) {",
		  "            ll z = y;",
		  "            for (int i = 0; i < len; i++) {",
		  "                z = f(z);",
		  "            }",
		  "            ll zs = -1;",
		  "            int lft = len;",
		  "            while(g == 1 && lft > 0) {",
		  "                zs = z;",
		  "                ll p = 1;",
		  "                for (int i = 0; i < B && i < lft; i++) {",
		  "                    p = mult(p, abs(z - y), x);",
		  "                    z = f(z);",
		  "                }",
		  "                g = gcd(p, x);",
		  "                lft -= B;",
		  "            }",
		  "            if (g == 1) {",
		  "                y = z;",
		  "                len <<= 1;",
		  "                continue;",
		  "            }",
		  "            if (g == x) {",
		  "                g = 1;",
		  "                z = zs;",
		  "                while(g == 1) {",
		  "                    g = gcd(abs(z - y), x);",
		  "                    z = f(z);",
		  "                }",
		  "            }",
		  "            if (g == x) break;",
		  "            assert(g != 1);",
		  "            pollard(g, ans);",
		  "            pollard(x / g, ans);",
		  "            return;",
		  "        }",
		  "    }",
		  "}",
		  "vector<ll> factorize(ll x) {",
		  "    vector<ll> ans;",
		  "    for (ll p : {2, 3, 5, 7, 11, 13, 17, 19}) {",
		  "        while(x % p == 0) {",
		  "            x /= p;",
		  "            ans.push_back(p);",
		  "        }",
		  "    }",
		  "    if (x != 1) {",
		  "        pollard(x, ans);",
		  "    }",
		  "    sort(ans.begin(), ans.end());",
		  "    return ans;",
		  "}"
		],
		"description": "Pollard Rho"
	  },
	  "Wavelet": {
		"prefix": "Wavelet",
		"body": [
		  "class Bit_Presum {",
		  "public:",
		  "    static constexpr uint32_t omega = CHAR_BIT * sizeof(uint64_t);",
		  "    static constexpr uint32_t lg_omega = __lg(omega);",
		  "    static_assert(omega == 64u);",
		  "",
		  "    Bit_Presum(vector<uint64_t> mask_)",
		  "            : n(mask_.size()), mask(move(mask_)), presum(n+1) {",
		  "        build();",
		  "    }",
		  "    Bit_Presum(uint32_t bits, bool init_val = 0)",
		  "            : n((bits>>lg_omega) + 1),",
		  "              mask(n, init_val ? ~uint64_t{0} : uint64_t{0}),",
		  "              presum(n+1) {",
		  "        if (init_val) mask.back()<<=((n<<lg_omega) - bits);",
		  "        build();",
		  "    }",
		  "    // popcount l <= i < r",
		  "    uint32_t query(uint32_t l, uint32_t r) const {",
		  "        if (__builtin_expect(r < l, false)) return 0;",
		  "        return query(r) - query(l);",
		  "    }",
		  "    // popcount 0 <= i < x",
		  "    uint32_t query(uint32_t x) const {",
		  "        uint32_t high = x>>lg_omega, low = x & ((uint64_t{1}<<lg_omega) - 1);",
		  "        uint32_t ret = presum_query(high);",
		  "        ret += __builtin_popcountll(mask[high]& ((uint64_t{1} << low)-1));",
		  "        return ret;",
		  "    }",
		  "",
		  "    void update_pre_build(uint32_t x, bool val) {",
		  "        uint32_t high = x>>lg_omega, low = x & ((1u<<lg_omega) - 1);",
		  "        mask[high] = (mask[high] & ~(uint64_t{1} << low)) | (uint64_t{val}<<low);",
		  "    }",
		  "    void do_build() {",
		  "        build();",
		  "    }",
		  "",
		  "    friend ostream& operator<<(ostream&o, Bit_Presum const&b) {",
		  "        for (auto const& e : b.mask) {",
		  "            stringstream ss;",
		  "            ss << bitset<omega>(e);",
		  "            auto s = ss.str();",
		  "            reverse(s.begin(), s.end());",
		  "            o << s << \"|\";",
		  "        }",
		  "        o << \" : \";",
		  "        for (auto const&e:b.presum) o << e << \" \";",
		  "        o << \"\\n\";",
		  "        return o;",
		  "    }",
		  "",
		  "private:",
		  "    void presum_build() {",
		  "        for (uint32_t x = 1; x <= n; ++x) {",
		  "            presum[x] += presum[x-1];",
		  "        }",
		  "    }",
		  "    // sum 0 <= i < x",
		  "    uint32_t presum_query(uint32_t x) const {",
		  "        return presum[x];",
		  "    }",
		  "    void build() {",
		  "        for (uint32_t x = 0; x < n; ++x) {",
		  "            presum[x+1] = __builtin_popcountll(mask[x]);",
		  "        }",
		  "        presum_build();",
		  "    }",
		  "",
		  "    const uint32_t n;",
		  "    vector<uint64_t> mask;",
		  "    vector<uint32_t> presum;",
		  "};",
		  "// }}}",
		  "",
		  "template<typename T, typename Bit_Ds = Bit_Presum>",
		  "class WaveletMatrix {",
		  "public:",
		  "    static_assert(is_integral<T>::value);",
		  "    static constexpr uint32_t height = CHAR_BIT * sizeof(T);",
		  "",
		  "    WaveletMatrix(vector<T> v): n(v.size()), data(height, n) {",
		  "        build(move(v));",
		  "    }",
		  "    // count l <= i < r  s.t.  A <= val[i] < B",
		  "    uint32_t range_count(int l, int r, T A, T B) const {",
		  "        assert(0 <= l && r <= n);",
		  "        return count_lower(l, r, B) - count_lower(l, r, A);",
		  "    }",
		  "    // count l <= i < r  s.t.  A <= val[i]",
		  "    uint32_t range_count_up(int l, int r, T A) const {",
		  "        assert(0 <= l && r <= n);",
		  "        if (__builtin_expect(l>r, false)) return uint32_t{0};",
		  "        return (r-l) - count_lower(l, r, A);",
		  "    }",
		  "    // k from 0",
		  "    // range: [l, r-1]",
		  "    T k_th(int l, int r, int k) const {",
		  "        assert(0 <= k && k < n);",
		  "        return get_kth(l, r, k);",
		  "    }",
		  "",
		  "    // internal functions {{{",
		  "private:",
		  "    void build(vector<T> v) {",
		  "        m_index.resize(height);",
		  "        T const a = numeric_limits<T>::min();",
		  "        for (int h = height-1; h>=0;--h) {",
		  "            T const b = a + (T{1}<<(max(0, h-1))) - !h + (T{1}<<(max(0, h-1)));",
		  "            for (int i=0;i<n;++i) {",
		  "                data[h].update_pre_build(i, v[i]<b);",
		  "            }",
		  "            data[h].do_build();",
		  "            const int m = stable_partition(v.begin(), v.end(), [&b](T const&x) {return x < b;}) - v.begin();",
		  "            for (int i=m;i<n;++i) {",
		  "                v[i] = v[i] - (T{1}<<(max(0, h-1))) + !h - (T{1}<<(max(0, h-1)));",
		  "            }",
		  "            m_index[h] = m;",
		  "        }",
		  "    }",
		  "    /// count l <= i < r  s.t.  val[i] < B",
		  "    uint32_t count_lower(int l, int r, T const&B) const {",
		  "        assert(0 <= l && r <= n);",
		  "        if (__builtin_expect(r<l, false)) return 0;",
		  "        uint32_t ret = 0;",
		  "        int h = height;",
		  "        T a = numeric_limits<T>::min();",
		  "        while(h > 0) {",
		  "            --h;",
		  "            bool go_left = B < a + (T{1}<<(max(0, h-1))) - !h + (T{1}<<(max(0, h-1)));",
		  "            const int low_l = data[h].query(l), low_r = data[h].query(r);",
		  "            if (go_left) {",
		  "                l = low_l;",
		  "                r = low_r;",
		  "            } else {",
		  "                a = a + (T{1}<<(max(0, h-1))) - !h + (T{1}<<(max(0, h-1)));",
		  "                ret+= low_r-low_l;",
		  "                l = m_index[h] + l-low_l;",
		  "                r = m_index[h] + r-low_r;",
		  "            }",
		  "        }",
		  "        return ret;",
		  "    }",
		  "    T get_kth(int l, int r, int k) const {",
		  "        assert(0 <= l && r <= n);",
		  "        assert(0 <= k && k < r-l);",
		  "        int h = height;",
		  "        T a = numeric_limits<T>::min();",
		  "        while (h > 0) {",
		  "            --h;",
		  "            const int low_l = data[h].query(l), low_r = data[h].query(r), low_lr = low_r-low_l;",
		  "            bool go_left = k < low_lr;",
		  "            if (go_left) {",
		  "                l = low_l;",
		  "                r = low_r;",
		  "            } else {",
		  "                a+= T{1}<<h;",
		  "                k-= low_lr;",
		  "                l = m_index[h] + l-low_l;",
		  "                r = m_index[h] + r-low_r;",
		  "            }",
		  "        }",
		  "        return a;",
		  "    }",
		  "",
		  "    const int n;",
		  "    vector<int> m_index;",
		  "    vector<Bit_Ds> data;",
		  "    // }}}",
		  "};"
		],
		"description": "Wavelet"
	  },
	  "Rand": {
		"prefix": "Rand",
		"body": [
		  "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
		  "long long get_rand(long long r) {",
		  "    return uniform_int_distribution<long long> (0, r-1)(rng);",
		  "}",
		  "long long get_rand(long long l, long long r){",
		  "    return l + rng() * 1ll * rng() % (r - l + 1);",
		  "}"
		],
		"description": "Rand"
	  },
	  "BinaryTrie": {
		"prefix": "BinaryTrie",
		"body": [
		  "template<",
		  "    class Val = long long,   // values stored in Trie",
		  "    class Count = long long, // frequency of values",
		  "    int B = (sizeof(Val) * 8 - 2)  // max number of bit",
		  "> struct BinaryTrie {",
		  "    struct Node {",
		  "        std::array<int, 2> child;",
		  "        Count count;",
		  "        Node() : child{-1, -1}, count(0) {}",
		  "    };",
		  "",
		  "    BinaryTrie() : nodes{Node()} {} // create root node",
		  "",
		  "    // Number of elements in the trie",
		  "    Count size() {",
		  "        return nodes[0].count;",
		  "    }",
		  "",
		  "    void insert(Val x, Count cnt = 1) {",
		  "        update(x, cnt);",
		  "    }",
		  "    void remove(Val x, Count cnt = 1) {",
		  "        update(x, -cnt);",
		  "    }",
		  "",
		  "    // return X: X ^ xor_val is minimum",
		  "    pair<Val, Node> min_element(Val xor_val = 0) {",
		  "        assert(0 < size());",
		  "        return kth_element(0, xor_val);",
		  "    }",
		  "",
		  "    // return X: X ^ xor_val is maximum",
		  "    pair<Val, Node> max_element(Val xor_val = 0) {",
		  "        assert(0 < size());",
		  "        return kth_element(size() - 1, xor_val);",
		  "    }",
		  "",
		  "    // return X: X ^ xor_val is K-th (0 <= K < size())",
		  "    pair<Val, Node> kth_element(Count k, Val xor_val = 0) {",
		  "        assert(0 <= k && k < size());",
		  "        int u = 0;",
		  "        Val x = 0;",
		  "        for (int i = B - 1; i >= 0; i--) {",
		  "            int b = get_bit(xor_val, i);",
		  "            int v0 = get_child(u, b);",
		  "            if (nodes[v0].count <= k) {",
		  "                k -= nodes[v0].count;",
		  "                u = get_child(u, 1-b);",
		  "                x |= 1LL << i;",
		  "            } else {",
		  "                u = v0;",
		  "            }",
		  "        }",
		  "        return {x, nodes[u]};",
		  "    }",
		  "",
		  "    // return frequency of x",
		  "    Count count(Val x) {",
		  "        int u = 0;",
		  "        for (int i = B - 1; i >= 0; i--) {",
		  "            int b = get_bit(x, i);",
		  "            if (nodes[u].child[b] == -1) {",
		  "                return 0;",
		  "            }",
		  "            u = get_child(u, b);",
		  "        }",
		  "        return nodes[u].count;",
		  "    }",
		  "",
		  "    //return how many numbers ^ xor_val less than x",
		  "    Count count_less(Val x, Val xor_val = 0){",
		  "        x ^= xor_val;",
		  "        int u = 0;",
		  "        Count res = 0;",
		  "        for(int i = B - 1; i >= 0; i--){",
		  "            int b = get_bit(x, i);",
		  "            if(b == 1){",
		  "                int up_node = get_child(u, 0);",
		  "                res += nodes[up_node].count;",
		  "            }",
		  "            u = get_child(u, b);",
		  "        }",
		  "        return res;",
		  "    }",
		  "",
		  "// private:",
		  "    vector<Node> nodes;",
		  "",
		  "    int get_child(int p, int b) {",
		  "        assert(0 <= p && p < (int) nodes.size());",
		  "        assert(0 <= b && b < 2);",
		  "        if (nodes[p].child[b] == -1) {",
		  "            nodes[p].child[b] = nodes.size();",
		  "            nodes.push_back(Node{});",
		  "        }",
		  "        return nodes[p].child[b];",
		  "    }",
		  "",
		  "    void update(Val x, Count cnt) {",
		  "        int u = 0;",
		  "        for (int i = B - 1; i >= 0; i--) {",
		  "            nodes[u].count += cnt;",
		  "            assert(nodes[u].count >= 0);  // prevent over delete",
		  "            int b = get_bit(x, i);",
		  "            u = get_child(u, b);",
		  "        }",
		  "        nodes[u].count += cnt;",
		  "        assert(nodes[u].count >= 0);  // prevent over delete",
		  "    }",
		  "",
		  "    inline int get_bit(Val v, int bit) {",
		  "        return (v >> bit) & 1;",
		  "    }",
		  "};"
		],
		"description": "BinaryTrie"
	  },
	  "HeavyLight": {
		"prefix": "HeavyLight",
		"body": [
		  "// Index from 0",
		  "// Best used with SegTree.h",
		  "//",
		  "// Usage:",
		  "// HLD hld(g, root);",
		  "// // build segment tree. Note that we must use hld.order[i]",
		  "// vector<T> nodes;",
		  "// for (int i = 0; i < n; i++)",
		  "//   nodes.push_back(initial_value[hld.order[i]])",
		  "// SegTree<S, op, e> st(nodes);",
		  "//",
		  "// // Update path",
		  "// hld.apply_path(from, to, is_edge, [&] (int l, int r) {",
		  "//   st.apply(l, r+1, F);",
		  "// });",
		  "//",
		  "// // Query path",
		  "// hld.prod_path_commutative<S, op, e> (from, to, is_edge, [&] (int l, int r) {",
		  "//   return st.prod(l, r+1);",
		  "// });",
		  "//",
		  "// Tested:",
		  "// - (vertex, path) https://judge.yosupo.jp/problem/vertex_add_path_sum",
		  "// - (vertex, path, non-commutative) https://judge.yosupo.jp/problem/vertex_set_path_composite",
		  "// - (vertex, subtree) https://judge.yosupo.jp/problem/vertex_add_subtree_sum",
		  "// - (vertex, path, non-commutative, 1-index) https://oj.vnoi.info/problem/icpc21_mt_l",
		  "// - (vertex, path) https://oj.vnoi.info/problem/qtree3",
		  "//",
		  "// - (edge, path) https://oj.vnoi.info/problem/qtreex",
		  "// - (edge, path) https://oj.vnoi.info/problem/lubenica",
		  "// - (edge, path) https://oj.vnoi.info/problem/pwalk",
		  "// - (edge, path, lazy) https://oj.vnoi.info/problem/kbuild",
		  "// - (edge, path, lazy) https://oj.vnoi.info/problem/onbridge",
		  "//",
		  "// - (lca) https://oj.vnoi.info/problem/fselect",
		  "// - (kth_parent) https://cses.fi/problemset/task/1687",
		  "// HeavyLight {{{",
		  "struct HLD {",
		  "    HLD(const vector<vector<int>>& _g, int root)",
		  "            : n(_g.size()), g(_g),",
		  "            parent(n), depth(n), sz(n),",
		  "            dfs_number(0), nxt(n), in(n), out(n), order(n)",
		  "    {",
		  "        assert(0 <= root && root < n);",
		  "",
		  "        // init parent, depth, sz",
		  "        // also move most heavy child of u to g[u][0]",
		  "        depth[root] = 0;",
		  "        dfs_sz(root, -1);",
		  "",
		  "        // init nxt, in, out",
		  "        nxt[root] = root;",
		  "        dfs_hld(root);",
		  "    }",
		  "",
		  "    int lca(int u, int v) const {",
		  "        assert(0 <= u && u < n);",
		  "        assert(0 <= v && v < n);",
		  "        while (true) {",
		  "            if (in[u] > in[v]) swap(u, v); // in[u] <= in[v]",
		  "            if (nxt[u] == nxt[v]) return u;",
		  "            v = parent[nxt[v]];",
		  "        }",
		  "    }",
		  "",
		  "    // return k-th parent",
		  "    // if no such parent -> return -1",
		  "    int kth_parent(int u, int k) const {",
		  "        assert(0 <= u && u < n);",
		  "        if (depth[u] < k) return -1;",
		  "",
		  "        while (true) {",
		  "            int v = nxt[u];",
		  "            if (in[u] - k >= in[v]) return order[in[u] - k];",
		  "            k -= in[u] - in[v] + 1;",
		  "            u = parent[v];",
		  "        }",
		  "    }",
		  "",
		  "    // return k-th vertex on path from u -> v (0 <= k)",
		  "    // if k > distance -> return -1",
		  "    int kth_vertex_on_path(int u, int v, int k) const {",
		  "        assert(0 <= u && u < n);",
		  "        assert(0 <= v && v < n);",
		  "",
		  "        int l = lca(u, v);",
		  "        int ul = depth[u] - depth[l];",
		  "        if (k <= ul) return kth_parent(u, k);",
		  "        k -= ul;",
		  "        int vl = depth[v] - depth[l];",
		  "        if (k <= vl) return kth_parent(v, vl - k);",
		  "        return -1;",
		  "    }",
		  "",
		  "    int dist(int u, int v) const {",
		  "        assert(0 <= u && u < n);",
		  "        assert(0 <= v && v < n);",
		  "        int l = lca(u, v);",
		  "        return depth[u] + depth[v] - 2*depth[l];",
		  "    }",
		  "",
		  "    // apply f on vertices on path [u, v]",
		  "    // edge = true -> apply on edge",
		  "    //",
		  "    // f(l, r) should update segment tree [l, r] INCLUSIVE",
		  "    void apply_path(int u, int v, bool edge, const function<void(int, int)> &f) {",
		  "        assert(0 <= u && u < n);",
		  "        assert(0 <= v && v < n);",
		  "        if (u == v && edge) return;",
		  "",
		  "        while (true) {",
		  "            if (in[u] > in[v]) swap(u, v); // in[u] <= in[v]",
		  "            if (nxt[u] == nxt[v]) break;",
		  "            f(in[nxt[v]], in[v]);",
		  "            v = parent[nxt[v]];",
		  "        }",
		  "        if (u == v && edge) return;",
		  "        f(in[u] + edge, in[v]);",
		  "    }",
		  "",
		  "    // get prod of path u -> v",
		  "    // edge = true -> get on edges",
		  "    //",
		  "    // f(l, r) should query segment tree [l, r] INCLUSIVE",
		  "    // f must be commutative. For non-commutative, use getSegments below",
		  "    template<class S, S (*op) (S, S), S (*e)()>",
		  "    S prod_path_commutative(",
		  "            int u, int v, bool edge,",
		  "            const function<S(int, int)>& f) const {",
		  "        assert(0 <= u && u < n);",
		  "        assert(0 <= v && v < n);",
		  "        if (u == v && edge) {",
		  "            return e();",
		  "        }",
		  "        S su = e(), sv = e();",
		  "        while (true) {",
		  "            if (in[u] > in[v]) { swap(u, v); swap(su, sv); }",
		  "            if (nxt[u] == nxt[v]) break;",
		  "            sv = op(sv, f(in[nxt[v]], in[v]));",
		  "            v = parent[nxt[v]];",
		  "        }",
		  "        if (u == v && edge) {",
		  "            return op(su, sv);",
		  "        } else {",
		  "            return op(su, op(sv, f(in[u] + edge, in[v])));",
		  "        }",
		  "    }",
		  "",
		  "    // f(l, r) modify seg_tree [l, r] INCLUSIVE",
		  "    void apply_subtree(int u, bool edge, const function<void(int, int)>& f) {",
		  "        assert(0 <= u && u < n);",
		  "        f(in[u] + edge, out[u] - 1);",
		  "    }",
		  "",
		  "    // f(l, r) queries seg_tree [l, r] INCLUSIVE",
		  "    template<class S>",
		  "    S prod_subtree_commutative(int u, bool edge, const function<S(S, S)>& f) {",
		  "        assert(0 <= u && u < n);",
		  "        return f(in[u] + edge, out[u] - 1);",
		  "    }",
		  "",
		  "    // Useful when functions are non-commutative",
		  "    // Return all segments on path from u -> v",
		  "    // For this problem, the order (u -> v is different from v -> u)",
		  "    vector< pair<int,int> > getSegments(int u, int v) const {",
		  "        assert(0 <= u && u < n);",
		  "        assert(0 <= v && v < n);",
		  "        vector< pair<int,int> > upFromU, upFromV;",
		  "",
		  "        int fu = nxt[u], fv = nxt[v];",
		  "        while (fu != fv) {  // u and v are on different chains",
		  "            if (depth[fu] >= depth[fv]) { // move u up",
		  "                upFromU.push_back({u, fu});",
		  "                u = parent[fu];",
		  "                fu = nxt[u];",
		  "            } else { // move v up",
		  "                upFromV.push_back({fv, v});",
		  "                v = parent[fv];",
		  "                fv = nxt[v];",
		  "            }",
		  "        }",
		  "        upFromU.push_back({u, v});",
		  "        reverse(upFromV.begin(), upFromV.end());",
		  "        upFromU.insert(upFromU.end(), upFromV.begin(), upFromV.end());",
		  "        return upFromU;",
		  "    }",
		  "",
		  "    // return true if u is ancestor",
		  "    bool isAncestor(int u, int v) {",
		  "        return in[u] <= in[v] && out[v] <= out[u];",
		  "    }",
		  "",
		  "// private:",
		  "    int n;",
		  "    vector<vector<int>> g;",
		  "    vector<int> parent;   // par[u] = parent of u. par[root] = -1",
		  "    vector<int> depth;    // depth[u] = distance from root -> u",
		  "    vector<int> sz;       // sz[u] = size of subtree rooted at u",
		  "    int dfs_number;",
		  "    vector<int> nxt;      // nxt[u] = vertex on heavy path of u, nearest to root",
		  "    vector<int> in, out;  // subtree(u) is in range [in[u], out[u]-1]",
		  "    vector<int> order;    // euler tour",
		  "",
		  "    void dfs_sz(int u, int fu) {",
		  "        parent[u] = fu;",
		  "        sz[u] = 1;",
		  "        // remove parent from adjacency list",
		  "        auto it = std::find(g[u].begin(), g[u].end(), fu);",
		  "        if (it != g[u].end()) g[u].erase(it);",
		  "",
		  "        for (int& v : g[u]) {",
		  "            depth[v] = depth[u] + 1;",
		  "            dfs_sz(v, u);",
		  "",
		  "            sz[u] += sz[v];",
		  "            if (sz[v] > sz[g[u][0]]) swap(v, g[u][0]);",
		  "        }",
		  "    }",
		  "",
		  "    void dfs_hld(int u) {",
		  "        order[dfs_number] = u;",
		  "        in[u] = dfs_number++;",
		  "",
		  "        for (int v : g[u]) {",
		  "            nxt[v] = (v == g[u][0] ? nxt[u] : v);",
		  "            dfs_hld(v);",
		  "        }",
		  "        out[u] = dfs_number;",
		  "    }",
		  "};",
		  "// }}}"
		],
		"description": "HeavyLight"
	  },
	  "MST": {
		"prefix": "MST",
		"body": [
		  "// MST. 0-based index",
		  "//",
		  "// Returns:",
		  "// {mst cost, edges in mst}",
		  "//",
		  "// If graph is not connected, returns forest (number of edges will be < n-1)",
		  "",
		  "#include \"../DataStructure/DisjointSet.h\"",
		  "using ll = long long;",
		  "struct Edge {",
		  "    int u, v;",
		  "    ll c;",
		  "};",
		  "bool operator < (const Edge& a, const Edge& b) {",
		  "    return a.c < b.c;",
		  "}",
		  "ostream& operator << (ostream& out, const Edge& e) {",
		  "    out << e.u << \" - \" << e.v << \" [\" << e.c << ']';",
		  "    return out;",
		  "}",
		  "std::pair<ll, std::vector<Edge>> mst(",
		  "        int n,",
		  "        std::vector<Edge> edges) {",
		  "    std::sort(edges.begin(), edges.end());",
		  "",
		  "    DSU dsu(n + 1);  // tolerate 1-based index",
		  "    ll total = 0;",
		  "    vector<Edge> tree;",
		  "    for (const auto& e : edges) {",
		  "        const auto [u, v, c] = e;",
		  "        if (dsu.merge(u, v)) {",
		  "            total += c;",
		  "            tree.push_back(e);",
		  "        }",
		  "    }",
		  "    return {total, tree};",
		  "}"
		],
		"description": "MST"
	  },
	  "DSU": {
		"prefix": "DSU",
		"body": [
		  "struct DSU {",
		  "    vector<int> lab;",
		  "",
		  "    DSU(int n) : lab(n+1, -1) {}",
		  "",
		  "    int getRoot(int u) {",
		  "        if (lab[u] < 0) return u;",
		  "        return lab[u] = getRoot(lab[u]);",
		  "    }",
		  "",
		  "    bool merge(int u, int v) {",
		  "        u = getRoot(u); v = getRoot(v);",
		  "        if (u == v) return false;",
		  "        if (lab[u] > lab[v]) swap(u, v);",
		  "        lab[u] += lab[v];",
		  "        lab[v] = u;",
		  "        return true;",
		  "    }",
		  "",
		  "    bool same_component(int u, int v) {",
		  "        return getRoot(u) == getRoot(v);",
		  "    }",
		  "",
		  "    int component_size(int u) {",
		  "        return -lab[getRoot(u)];",
		  "    }",
		  "};"
		],
		"description": "DSU"
	  },
	  "DSU_Roll": {
		"prefix": "DSU_Roll",
		"body": [
		  "struct Data {",
		  "    int time, u, par;  // before `time`, `par` = par[u]",
		  "};",
		  "",
		  "struct DSU {",
		  "    vector<int> par;",
		  "    vector<Data> change;",
		  "",
		  "    DSU(int n) : par(n + 5, -1) {}",
		  "",
		  "    // find root of x.",
		  "    // if par[x] < 0 then x is a root, and its tree has -par[x] nodes",
		  "    int getRoot(int x) {",
		  "        while (par[x] >= 0)",
		  "            x = par[x];",
		  "        return x;",
		  "    }",
		  "",
		  "    bool same_component(int u, int v) {",
		  "        return getRoot(u) == getRoot(v);",
		  "    }",
		  "",
		  "    // join components containing x and y.",
		  "    // t should be current time. We use it to update `change`.",
		  "    bool join(int x, int y, int t) {",
		  "        x = getRoot(x);",
		  "        y = getRoot(y);",
		  "        if (x == y) return false;",
		  "",
		  "        //union by rank",
		  "        if (par[x] < par[y]) swap(x, y); ",
		  "        //now x's tree has less nodes than y's tree",
		  "        change.push_back({t, y, par[y]});",
		  "        par[y] += par[x];",
		  "        change.push_back({t, x, par[x]});",
		  "        par[x] = y;",
		  "        return true;",
		  "    }",
		  "",
		  "    // rollback all changes at time > t.",
		  "    void rollback(int t) {",
		  "        while (!change.empty() && change.back().time > t) {",
		  "            par[change.back().u] = change.back().par;",
		  "            change.pop_back();",
		  "        }",
		  "    }",
		  "};"
		],
		"description": "DSU_Roll"
	  },
	  "ZFUNC": {
		"prefix": "ZFUNC",
		"body": [
		  "vector<int> zfunc(string s) {",
		  "    int n = (int) s.length();",
		  "    vector<int> z(n);",
		  "    for (int i = 1, l = 0, r = 0; i < n; ++i) {",
		  "        if (i <= r)",
		  "            z[i] = min(r - i + 1, z[i - l]);",
		  "        while (i + z[i] < n && s[z[i]] == s[i + z[i]])",
		  "            ++z[i];",
		  "        if (i + z[i] - 1 > r)",
		  "            l = i, r = i + z[i] - 1;",
		  "    }",
		  "    return z;",
		  "}"
		],
		"description": "ZFUNC"
	  },
	  "Manacher": {
		"prefix": "Manacher",
		"body": [
		  "// Manacher {{{",
		  "// Return <even_len, odd_len>",
		  "// - even_len[i] = length of longest palindrome centered at [i, i+1]",
		  "// - odd_len[i] = length of longest palindrome centered at i",
		  "//",
		  "// Tested:",
		  "// - https://judge.yosupo.jp/problem/enumerate_palindromes",
		  "// - https://oj.vnoi.info/problem/paliny",
		  "std::array<vector<int>, 2> manacher(const string& s) {",
		  "    int n = s.size();",
		  "    std::array res = {vector<int> (n+1, 0), vector<int> (n, 0)};",
		  "",
		  "    for (int z = 0; z < 2; z++) {",
		  "        for (int i = 0, l = 0, r = 0; i < n; i++) {",
		  "            int t = r - i + !z;",
		  "            if (i < r) res[z][i] = min(t, res[z][l + t]);",
		  "",
		  "            int l2 = i - res[z][i], r2 = i + res[z][i] - !z;",
		  "            while (l2 && r2 + 1 < n && s[l2 - 1] == s[r2 + 1]) {",
		  "                ++res[z][i];",
		  "                --l2;",
		  "                ++r2;",
		  "            }",
		  "            if (r2 > r) {",
		  "                l = l2;",
		  "                r = r2;",
		  "            }",
		  "        }",
		  "        for (int i = 0; i < n; i++) {",
		  "            res[z][i] = 2*res[z][i] + z;",
		  "        }",
		  "    }",
		  "    res[0].erase(res[0].begin(), res[0].begin() + 1);",
		  "    res[0].pop_back();",
		  "    return res;",
		  "}"
		],
		"description": "Manacher"
	  },
	  "Trie": {
		"prefix": "Trie",
		"body": [
		  "struct Trie {",
		  "    Trie(int _nChild, char _offset)",
		  "        : nChild(_nChild), offset(_offset),",
		  "        children(1, std::vector<int> (_nChild, -1)) {}",
		  "",
		  "    // Add a new string s to Trie. Returns ID of new node",
		  "    int add(const string& s) {",
		  "        int p = 0;",
		  "        for (char c : s) {",
		  "            p = getChild(p, c, /* create= */ true);",
		  "        }",
		  "        return p;",
		  "    }",
		  "",
		  "    // Follow string s on trie, and return ID of node.",
		  "    // Returns -1 if no such node.",
		  "    int get(const string& s) {",
		  "        int p = 0;",
		  "        for (char c : s) {",
		  "            p = getChild(p, c);",
		  "            if (p < 0) return -1;",
		  "        }",
		  "        return p;",
		  "    }",
		  "",
		  "    // Create a new child of p, edge from p -> child = c",
		  "    // Returns ID of new node",
		  "    int addNode(int p, char c) {",
		  "        // create child node",
		  "        int child = children.size();",
		  "        children.push_back(std::vector<int> (nChild, -1));",
		  "",
		  "        // link",
		  "        children[p][c - offset] = child;",
		  "        return child;",
		  "    }",
		  "",
		  "    bool hasChild(int p, char c) {",
		  "        return children[p][c - offset] >= 0;",
		  "    }",
		  "",
		  "    // Returns -1 if no such child, otherwise returns ID of child",
		  "    // If create = true (useful for adding strings to trie), a new",
		  "    // child is created if not exist",
		  "    int getChild(int p, char c, bool create=false) {",
		  "        assert(p < (int) children.size());",
		  "",
		  "        if (!hasChild(p, c) && create) {",
		  "            return addNode(p, c);",
		  "        }",
		  "",
		  "        return children[p][c - offset];",
		  "    }",
		  "",
		  "    int nChild;",
		  "    char offset;",
		  "    std::vector<std::vector<int>> children;",
		  "};"
		],
		"description": "Trie"
	  },
	  "SuffixArray": {
		"prefix": "SA",
		"body": [
		  "// Efficient O(N + alphabet_size) time and space suffix array",
		  "// For ICPC notebook, it's better to copy a shorter code such as",
		  "// https://github.com/kth-competitive-programming/kactl/blob/main/content/strings/SuffixArray.h",
		  "",
		  "// Usage:",
		  "// - sa = suffix_array(s, 'a', 'z')",
		  "// - lcp = LCP(s, sa)",
		  "//   lcp[i] = LCP(sa[i], sa[i+1])",
		  "//",
		  "// Tested:",
		  "// - SA https://judge.yosupo.jp/problem/suffixarray",
		  "// - SA https://www.spoj.com/problems/SARRAY/",
		  "// - LCP https://judge.yosupo.jp/problem/number_of_substrings",
		  "// Suffix Array {{{",
		  "// Copied from https://judge.yosupo.jp/submission/52300",
		  "// Helper functions {{{",
		  "void induced_sort(const std::vector<int>& vec, int val_range,",
		  "                  std::vector<int>& SA, const std::vector<bool>& sl,",
		  "                  const std::vector<int>& lms_idx) {",
		  "    std::vector<int> l(val_range, 0), r(val_range, 0);",
		  "    for (int c : vec) {",
		  "        if (c + 1 < val_range) ++l[c + 1];",
		  "        ++r[c];",
		  "    }",
		  "    std::partial_sum(l.begin(), l.end(), l.begin());",
		  "    std::partial_sum(r.begin(), r.end(), r.begin());",
		  "    std::fill(SA.begin(), SA.end(), -1);",
		  "    for (int i = (int)lms_idx.size() - 1; i >= 0; --i)",
		  "        SA[--r[vec[lms_idx[i]]]] = lms_idx[i];",
		  "    for (int i : SA)",
		  "        if (i >= 1 && sl[i - 1]) SA[l[vec[i - 1]]++] = i - 1;",
		  "    std::fill(r.begin(), r.end(), 0);",
		  "    for (int c : vec) ++r[c];",
		  "    std::partial_sum(r.begin(), r.end(), r.begin());",
		  "    for (int k = (int)SA.size() - 1, i = SA[k]; k >= 1; --k, i = SA[k])",
		  "        if (i >= 1 && !sl[i - 1]) {",
		  "            SA[--r[vec[i - 1]]] = i - 1;",
		  "        }",
		  "}",
		  "",
		  "std::vector<int> SA_IS(const std::vector<int>& vec, int val_range) {",
		  "    const int n = vec.size();",
		  "    std::vector<int> SA(n), lms_idx;",
		  "    std::vector<bool> sl(n);",
		  "    sl[n - 1] = false;",
		  "    for (int i = n - 2; i >= 0; --i) {",
		  "        sl[i] = (vec[i] > vec[i + 1] || (vec[i] == vec[i + 1] && sl[i + 1]));",
		  "        if (sl[i] && !sl[i + 1]) lms_idx.push_back(i + 1);",
		  "    }",
		  "    std::reverse(lms_idx.begin(), lms_idx.end());",
		  "    induced_sort(vec, val_range, SA, sl, lms_idx);",
		  "    std::vector<int> new_lms_idx(lms_idx.size()), lms_vec(lms_idx.size());",
		  "    for (int i = 0, k = 0; i < n; ++i)",
		  "        if (!sl[SA[i]] && SA[i] >= 1 && sl[SA[i] - 1]) {",
		  "            new_lms_idx[k++] = SA[i];",
		  "        }",
		  "    int cur = 0;",
		  "    SA[n - 1] = cur;",
		  "    for (size_t k = 1; k < new_lms_idx.size(); ++k) {",
		  "        int i = new_lms_idx[k - 1], j = new_lms_idx[k];",
		  "        if (vec[i] != vec[j]) {",
		  "            SA[j] = ++cur;",
		  "            continue;",
		  "        }",
		  "        bool flag = false;",
		  "        for (int a = i + 1, b = j + 1;; ++a, ++b) {",
		  "            if (vec[a] != vec[b]) {",
		  "                flag = true;",
		  "                break;",
		  "            }",
		  "            if ((!sl[a] && sl[a - 1]) || (!sl[b] && sl[b - 1])) {",
		  "                flag = !((!sl[a] && sl[a - 1]) && (!sl[b] && sl[b - 1]));",
		  "                break;",
		  "            }",
		  "        }",
		  "        SA[j] = (flag ? ++cur : cur);",
		  "    }",
		  "    for (size_t i = 0; i < lms_idx.size(); ++i) lms_vec[i] = SA[lms_idx[i]];",
		  "    if (cur + 1 < (int)lms_idx.size()) {",
		  "        auto lms_SA = SA_IS(lms_vec, cur + 1);",
		  "        for (size_t i = 0; i < lms_idx.size(); ++i) {",
		  "            new_lms_idx[i] = lms_idx[lms_SA[i]];",
		  "        }",
		  "    }",
		  "    induced_sort(vec, val_range, SA, sl, new_lms_idx);",
		  "    return SA;",
		  "}",
		  "// }}}",
		  "",
		  "template<typename ContainerT = std::string, typename ElemT = unsigned char>",
		  "std::vector<int> suffix_array(const ContainerT& s, const ElemT first = 'a',",
		  "                         const ElemT last = 'z') {",
		  "    std::vector<int> vec(s.size() + 1);",
		  "    std::copy(std::begin(s), std::end(s), std::begin(vec));",
		  "    for (auto& x : vec) x -= (int)first - 1;",
		  "    vec.back() = 0;",
		  "    auto ret = SA_IS(vec, (int)last - (int)first + 2);",
		  "    ret.erase(ret.begin());",
		  "    return ret;",
		  "}",
		  "// Author: https://codeforces.com/blog/entry/12796?#comment-175287",
		  "// Uses kasai's algorithm linear in time and space",
		  "std::vector<int> LCP(const std::string& s, const std::vector<int>& sa) {",
		  "    int n = s.size(), k = 0;",
		  "    std::vector<int> lcp(n), rank(n);",
		  "    for (int i = 0; i < n; i++) rank[sa[i]] = i;",
		  "    for (int i = 0; i < n; i++, k ? k-- : 0) {",
		  "        if (rank[i] == n - 1) {",
		  "            k = 0;",
		  "            continue;",
		  "        }",
		  "        int j = sa[rank[i] + 1];",
		  "        while (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;",
		  "        lcp[rank[i]] = k;",
		  "    }",
		  "    lcp[n - 1] = 0;",
		  "    return lcp;",
		  "}",
		  "// }}}",
		  "// Number of distinct substrings {{{",
		  "// Tested:",
		  "// - https://judge.yosupo.jp/problem/number_of_substrings",
		  "// - https://www.spoj.com/problems/SUBST1/",
		  "int64_t cnt_distinct_substrings(const std::string& s) {",
		  "    auto lcp = LCP(s, suffix_array(s, 0, 255));",
		  "    return s.size() * (int64_t) (s.size() + 1) / 2",
		  "        - std::accumulate(lcp.begin(), lcp.end(), 0LL);",
		  "}",
		  "// }}}",
		  "// K-th distinct substring {{{",
		  "// Tested:",
		  "// - https://cses.fi/problemset/task/2108",
		  "// - https://www.spoj.com/problems/SUBLEX/",
		  "",
		  "// Consider all distinct substring of string `s` in lexicographically increasing",
		  "// order. Find k-th substring.",
		  "//",
		  "// Preprocessing: O(N)",
		  "// Each query: O(log(N))",
		  "//",
		  "// Returns {start index, length}. If not found -> {-1, -1}",
		  "std::vector<std::pair<int,int>> kth_distinct_substring(",
		  "        const std::string& s,",
		  "        const std::vector<int64_t>& ks) {",
		  "    if (s.empty()) {",
		  "        return {};",
		  "    }",
		  "    auto sa = suffix_array(s, 0, 255);",
		  "    auto lcp = LCP(s, sa);",
		  "    int n = s.size();",
		  "    ",
		  "    // for each suffix (in increasing order), we count how many new distinct",
		  "    // substrings it create",
		  "    std::vector<int64_t> n_new_substrs(n);",
		  "    for (int i = 0; i < n; ++i) {",
		  "        int substr_len = n - sa[i];",
		  "        int new_substr_start = (i > 0 ? lcp[i-1] : 0);",
		  "        n_new_substrs[i] = substr_len - new_substr_start;",
		  "    }",
		  "    std::partial_sum(n_new_substrs.begin(), n_new_substrs.end(), n_new_substrs.begin());",
		  "",
		  "    std::vector<std::pair<int,int>> res;",
		  "    for (int64_t k : ks) {",
		  "        if (k > *n_new_substrs.rbegin()) {",
		  "            res.emplace_back(-1, -1);",
		  "        } else {",
		  "            int i = std::lower_bound(n_new_substrs.begin(), n_new_substrs.end(), k) - n_new_substrs.begin();",
		  "            int new_substr_start = (i > 0 ? lcp[i-1] : 0);",
		  "            if (i > 0) k -= n_new_substrs[i-1];",
		  "            res.emplace_back(sa[i], new_substr_start + k);",
		  "        }",
		  "    }",
		  "    return res;",
		  "}",
		  "// }}}",
		  "// Count substring occurrences {{{",
		  "// given string S and Q queries pat_i, for each query, count how many",
		  "// times pat_i appears in S",
		  "// O(min(|S|, |pat|) * log(|S|)) per query",
		  "//",
		  "// Tested:",
		  "// - (yes / no) https://cses.fi/problemset/task/2102",
		  "// - (count) https://cses.fi/problemset/task/2103",
		  "// - (position; need RMQ) https://cses.fi/problemset/task/2104",
		  "int cnt_occurrences(const string& s, const vector<int>& sa, const string& pat) {",
		  "    int n = s.size(), m = pat.size();",
		  "    assert(n == (int) sa.size());",
		  "    if (n < m) return 0;",
		  " ",
		  "    auto f = [&] (int start) {  // compare S[start..] and pat[0..]",
		  "        for (int i = 0; start + i < n && i < m; ++i) {",
		  "            if (s[start + i] < pat[i]) return true;",
		  "            if (s[start + i] > pat[i]) return false;",
		  "        }",
		  "        return n - start < m;",
		  "    };",
		  "    auto g = [&] (int start) {",
		  "        for (int i = 0; start + i < n && i < m; ++i) {",
		  "            if (s[start + i] > pat[i]) return false;",
		  "        }",
		  "        return true;",
		  "    };",
		  "    auto l = std::partition_point(sa.begin(), sa.end(), f);",
		  "    auto r = std::partition_point(l, sa.end(), g);",
		  "    // To find first occurrence, return min of sa in range [l, r)",
		  "    // See https://cses.fi/problemset/task/2104",
		  "    return std::distance(l, r);",
		  "}",
		  "// }}}",
		  "// Count substring occurrences using hash {{{",
		  "// If hash array can be pre-computed, can answer each query in",
		  "// O(log(|S|) * log(|S| + |pat|)",
		  "// Tested",
		  "// - https://oj.vnoi.info/problem/icpc22_mt_b",
		  "#include \"./hash.h\"",
		  "int cnt_occurrences_hash(",
		  "        const vector<int>& sa,        // suffix array",
		  "        const HashGenerator& gen,",
		  "        const string& s,",
		  "        const vector<Hash>& hash_s,   // hash of `s`, generated with `gen`",
		  "        const string_view& pat,",
		  "        const vector<Hash>& hash_pat  // hash of `pat`, generated with `gen`",
		  "        ) {",
		  "    int n = s.size(), len = pat.size();",
		  "    assert(len == (int) hash_pat.size());",
		  "    assert(n == (int) sa.size());",
		  "    if (n < len) return 0;",
		  "",
		  "    // f(start) = compare string S[start..] and pat[0..len-1]",
		  "    auto f = [&] (int start) {",
		  "        return gen.cmp(",
		  "                s, hash_s, start, n-1,",
		  "                pat, hash_pat, 0, len-1) < 0;",
		  "    };",
		  "    // g(start) = true if S[start..] == pat[0..]",
		  "    auto g = [&] (int start) {",
		  "        int max_len = std::min(n - start, len);",
		  "        return gen.cmp(",
		  "                s, hash_s, start, start + max_len - 1,",
		  "                pat, hash_pat, 0, max_len-1) == 0;",
		  "    };",
		  "    auto l = std::partition_point(sa.begin(), sa.end(), f);",
		  "    auto r = std::partition_point(l, sa.end(), g);",
		  "    return std::distance(l, r);",
		  "}",
		  "// }}}",
		  "// Returns length of LCS of strings s & t {{{",
		  "// O(N)",
		  "// Tested:",
		  "// - https://www.spoj.com/problems/LCS/",
		  "// - https://www.spoj.com/problems/ADAPHOTO/",
		  "int longestCommonSubstring(const string& s, const string& t) {",
		  "    char c = 127;",
		  "    string combined = s + c + t;",
		  "    auto sa = suffix_array(combined, 0, 127);",
		  "    auto lcp = LCP(combined, sa);",
		  " ",
		  "    // s -> 0 .. |s|-1",
		  "    // 255 -> |s|",
		  "    // t -> |s|+1 ..",
		  "    int ls = s.size(), lcombined = combined.size();",
		  "    auto is_s = [&] (int id) { return sa[id] < ls; };",
		  "    auto is_t = [&] (int id) { return sa[id] > ls; };",
		  " ",
		  "    assert(sa[lcombined - 1] == ls);",
		  " ",
		  "    int res = 0;",
		  "    for (int i = 0; i < lcombined - 2; ++i) {",
		  "        if ((is_s(i) && is_t(i+1)) || (is_s(i+1) && is_t(i))) {",
		  "            res = max(res, lcp[i]);",
		  "        }",
		  "    }",
		  "    return res;",
		  "}",
		  "// }}}",
		  "// Returns length of LCS of n strings {{{",
		  "// Tested:",
		  "// - https://www.spoj.com/problems/LCS2/",
		  "// - https://www.spoj.com/problems/LONGCS",
		  "#include \"../DataStructure/RMQ.h\"",
		  "int longestCommonSubstring(const std::vector<std::string> strs) {",
		  "    char c = 127;",
		  "    string combined = \"\";",
		  "    vector<int> ids;",
		  "    for (size_t i = 0; i < strs.size(); ++i) {",
		  "        const auto& s = strs[i];",
		  "        combined += s;",
		  "        while (ids.size() < combined.size()) ids.push_back(i);",
		  "",
		  "        combined += c;",
		  "        ids.push_back(-1);",
		  "",
		  "        --c;",
		  "    }",
		  "    auto sa = suffix_array(combined, 0, 127);",
		  "    auto lcp = LCP(combined, sa);",
		  "    RMQ<int, _min> rmq(lcp);",
		  "",
		  "    // count frequency of i-th string in current window",
		  "    std::vector<int> cnt(strs.size(), 0);",
		  "    int strs_in_window = 0;",
		  "    auto add = [&] (int i) {",
		  "        if (i < 0) return;",
		  "        ++cnt[i];",
		  "        if (cnt[i] == 1) ++strs_in_window;",
		  "    };",
		  "    auto rem = [&] (int i) {",
		  "        if (i < 0) return;",
		  "        --cnt[i];",
		  "        if (cnt[i] == 0) --strs_in_window;",
		  "    };",
		  "",
		  "    int i = 0, j = -1;",
		  "    int lcombined = combined.size();",
		  "    int n = strs.size();",
		  "    int res = 0;",
		  "    while (i < lcombined - 1) {",
		  "        while (j + 1 < lcombined - 1 && strs_in_window < n) {",
		  "            ++j;",
		  "            add(ids[sa[j]]);",
		  "        }",
		  "        if (strs_in_window == n) {",
		  "            res = max(res, rmq.get(i, j));",
		  "        }",
		  "",
		  "        rem(ids[sa[i]]); ++i;",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": "SuffixArray"
	  },
	  "SegmentTree": {
		"prefix": "SegmentTree",
		"body": [
		  "template<const int N>",
		  "struct SegmentTree{",
		  "    struct node{",
		  "        node(){}",
		  "    } tree[4 * N];",
		  "",
		  "    node combine(const node &left, const node &right){",
		  "        node com;",
		  "        return com;",
		  "    }",
		  "",
		  "    void build(int index, int l, int r){",
		  "        if(l == r){",
		  "            return;",
		  "        }",
		  "        int mid = (l + r) / 2;",
		  "        build(index * 2, l, mid);",
		  "        build(index * 2 + 1, mid + 1, r);",
		  "        tree[index] = combine(tree[index * 2], tree[index * 2 + 1]);",
		  "    }",
		  "    void update_lazy(int index, int l, int r){",
		  "        if(l == r) return;",
		  "    }",
		  "    void update(int index, int l, int r, int u, int v){",
		  "        update_lazy(index, l, r);",
		  "        if(u > r || v < l) return;",
		  "        if(l >= u && r <= v){",
		  "            return;",
		  "        }",
		  "        int mid = (l + r) / 2;",
		  "        update(index * 2, l, mid, u, v);",
		  "        update(index * 2 + 1, mid + 1, r, u, v);",
		  "        tree[index] = combine(tree[index * 2], tree[index * 2 + 1]);",
		  "    }",
		  "    void update_point(int index, int l, int r, int u){",
		  "        update_lazy(index, l, r);",
		  "        if(u < l || u > r) return;",
		  "        if(l == r){",
		  "            return;",
		  "        }",
		  "        int mid = (l + r) / 2;",
		  "        update_point(index * 2, l, mid, u);",
		  "        update_point(index * 2 + 1, mid + 1, r, u);",
		  "        tree[index] = combine(tree[index * 2], tree[index * 2 + 1]);",
		  "    }",
		  "    void query(int index, int l, int r, int u, int v){",
		  "        update_lazy(index, l, r);",
		  "        if(u > r || v < l) return;",
		  "        if(l >= u && r <= v){",
		  "            return;",
		  "        }",
		  "        int mid = (l + r) / 2;",
		  "        query(index * 2, l, mid, u, v);",
		  "        query(index * 2 + 1, mid + 1, r, u, v);",
		  "    }",
		  "};"
		],
		"description": "SegmentTree"
	  },
	  "Fenwick": {
		"prefix": "Fenwick",
		"body": [
		  "template<typename T>",
		  "struct Fenwick{",
		  "    vector<T> tree;",
		  "    int n;",
		  "    Fenwick(int n) : n(n), tree(n + 5, 0){",
		  "    }",
		  "    void update(int u, T v){",
		  "        for(int i = u; i <= n; i += i & -i){",
		  "            tree[i] += v; ",
		  "        }",
		  "    }",
		  "    T get(int u){",
		  "        T res = 0;",
		  "        for(int i = u; i > 0; i -= i & -i){",
		  "            res += tree[i];",
		  "        }",
		  "        return res;",
		  "    }",
		  "    T get(int l, int r){",
		  "        return get(r) - get(l - 1);",
		  "    }",
		  "};"
		],
		"description": "Fenwick"
	  },
	  "Linehull": {
		"prefix": "Linehull",
		"body": [
		  "#define double long double",
		  "typedef long long num_t;",
		  "const num_t oo = (num_t)1e18;",
		  "struct LineHull {",
		  "  struct Line {",
		  "    num_t a, b;",
		  "    Line(num_t a, num_t b) : a(a), b(b) {}",
		  "  };",
		  "  double intersect(Line ln1, Line ln2) {",
		  "    return (double)(ln2.b - ln1.b) / (ln1.a - ln2.a);",
		  "  }",
		  "  int bad(Line ln1, Line ln2, Line ln3) {",
		  "    return (double)(ln1.a - ln2.a) * (ln2.b - ln3.b) >=",
		  "           (double)(ln2.a - ln3.a) * (ln1.b - ln2.b);",
		  "    // return intersect(ln1, ln2) >= intersect(ln2, ln3);",
		  "    // return (double) (ln1.a - ln2.a) * (ln2.b - ln3.b) <= (double) (ln2.a -",
		  "    // ln3.a) * (ln1.b - ln2.b); //for adding in ascending order return",
		  "    // intersect(ln1, ln2) <= intersect(ln2, ln3); //for adding in ascending",
		  "    // order",
		  "  }",
		  "  vector<Line> hull;",
		  "  vector<double> pos;",
		  "  LineHull() {",
		  "    pos.push_back(-oo);",
		  "    pos.push_back(+oo);",
		  "  }",
		  "  void add(num_t a, num_t b) {",
		  "    Line ln(a, b);",
		  "    pos.pop_back();",
		  "    while (hull.size() >= 2 &&",
		  "           bad(hull[hull.size() - 2], hull[hull.size() - 1], ln)) {",
		  "      hull.pop_back();",
		  "      pos.pop_back();",
		  "    }",
		  "    hull.push_back(ln);",
		  "    if (hull.size() >= 2)",
		  "      pos.push_back(intersect(hull[hull.size() - 2], hull[hull.size() - 1]));",
		  "    // if (hull.size() >= 2) pos.push_back(-intersect(hull[hull.size() - 2],",
		  "    // hull[hull.size() - 1])); //for adding in ascending order",
		  "    pos.push_back(+oo);",
		  "  }",
		  "  num_t query(num_t x) {",
		  "    if (!hull.size())",
		  "      return +oo;",
		  "    int k = lower_bound(pos.begin(), pos.end(), x) - pos.begin() - 1;",
		  "    // int k = lower_bound(pos.begin(), pos.end(), -x) - pos.begin() - 1; //for",
		  "    // adding in ascending order",
		  "    return hull[k].a * x + hull[k].b;",
		  "  }",
		  "} lh;",
		  "#undef double"
		],
		"description": "Linehull"
	  },
	  "PrioritySumStructure ": {
		"prefix": "PrioritySumStructure ",
		"body": [
		  "/*",
		  "use to find the sum of top k elements",
		  "usage: Minimum(k), maximum(k)",
		  "query() : return top k elements O(1)",
		  "erase(x), insert(x) : O(logn)",
		  "set(k) : respecify k",
		  "get() : return k",
		  "size():",
		  "*/",
		  "",
		  "template< typename T, typename Compare = less< T >, typename RCompare = greater< T > >",
		  "struct PrioritySumStructure {",
		  "",
		  "  size_t k;",
		  "  T sum;",
		  "",
		  "  priority_queue< T, vector< T >, Compare > in, d_in;",
		  "  priority_queue< T, vector< T >, RCompare > out, d_out;",
		  "",
		  "  PrioritySumStructure(int k) : k(k), sum(0) {}",
		  "",
		  "  void modify() {",
		  "    while(in.size() - d_in.size() < k && !out.empty()) {",
		  "      auto p = out.top();",
		  "      out.pop();",
		  "      if(!d_out.empty() && p == d_out.top()) {",
		  "        d_out.pop();",
		  "      } else {",
		  "        sum += p;",
		  "        in.emplace(p);",
		  "      }",
		  "    }",
		  "    while(in.size() - d_in.size() > k) {",
		  "      auto p = in.top();",
		  "      in.pop();",
		  "      if(!d_in.empty() && p == d_in.top()) {",
		  "        d_in.pop();",
		  "      } else {",
		  "        sum -= p;",
		  "        out.emplace(p);",
		  "      }",
		  "    }",
		  "    while(!d_in.empty() && in.top() == d_in.top()) {",
		  "      in.pop();",
		  "      d_in.pop();",
		  "    }",
		  "  }",
		  "",
		  "  T query() const {",
		  "    return sum;",
		  "  }",
		  "",
		  "  void insert(T x) {",
		  "    in.emplace(x);",
		  "    sum += x;",
		  "    modify();",
		  "  }",
		  "",
		  "  void erase(T x) {",
		  "    assert(size());",
		  "    if(!in.empty() && in.top() == x) {",
		  "      sum -= x;",
		  "      in.pop();",
		  "    } else if(!in.empty() && RCompare()(in.top(), x)) {",
		  "      sum -= x;",
		  "      d_in.emplace(x);",
		  "    } else {",
		  "      d_out.emplace(x);",
		  "    }",
		  "    modify();",
		  "  }",
		  "",
		  "  void set_k(size_t kk) {",
		  "    k = kk;",
		  "    modify();",
		  "  }",
		  "",
		  "  size_t get_k() const {",
		  "    return k;",
		  "  }",
		  "",
		  "  size_t size() const {",
		  "    return in.size() + out.size() - d_in.size() - d_out.size();",
		  "  }",
		  "};",
		  "",
		  "template< typename T >",
		  "using MaximumSum = PrioritySumStructure< T, greater< T >, less< T > >;",
		  "",
		  "template< typename T >",
		  "using MinimumSum = PrioritySumStructure< T, less< T >, greater< T > >;"
		],
		"description": "PrioritySumStructure "
	  },
	  "RMQ2D": {
		"prefix": "RMQ2D",
		"body": [
		  "/*",
		  "    usage:",
		  "    rmq.init(n, m);",
		  "    cin >> rmq[i][j]",
		  "    rmq.build();",
		  "*/",
		  "",
		  "template <class num_t> struct RMQ2D {",
		  "  static const int maxn = 1e3 + 5;",
		  "  static const int maxm = 1e3 + 5;",
		  "  static const int logn = 10 + 1;",
		  "  static const int logm = 10 + 1;",
		  "  int n, m;",
		  "  num_t a[maxn][maxm];",
		  "  num_t f[logm][maxn][maxm];",
		  "  num_t g[logm][logn][maxm][maxn];",
		  "",
		  "  inline num_t best(const num_t &a, const num_t &b) {",
		  "    return a < b ? a : b;",
		  "  }",
		  "  void init(int _n, int _m) { n = _n, m = _m; }",
		  "  num_t *operator[](int u) {",
		  "    assert(u < n);",
		  "    return a[u];",
		  "  }",
		  "  void build() {",
		  "    for (int k = 1; k <= n; k++) {",
		  "      for (int i = 1; i <= m; i++) {",
		  "        f[0][k][i] = a[k - 1][i - 1];",
		  "      }",
		  "      for (int j = 1; 1 << j <= m; j++) {",
		  "        for (int i = 0; i + (1 << j) - 1 <= m; i++) {",
		  "          f[j][k][i] = best(f[j - 1][k][i], f[j - 1][k][i + (1 << (j - 1))]);",
		  "        }",
		  "      }",
		  "    }",
		  "    for (int k = 1; k <= m; k++) {",
		  "      for (int l = 0; k + (1 << l) - 1 <= m; l++) {",
		  "        for (int i = 1; i <= n; i++) {",
		  "          g[l][0][k][i] = f[l][i][k];",
		  "        }",
		  "        for (int j = 1; 1 << j <= n; j++) {",
		  "          for (int i = 0; i + (1 << j) - 1 <= n; i++) {",
		  "            g[l][j][k][i] =",
		  "                best(g[l][j - 1][k][i], g[l][j - 1][k][i + (1 << (j - 1))]);",
		  "          }",
		  "        }",
		  "      }",
		  "    }",
		  "  }",
		  "  num_t query(int x, int y, int z, int t) {",
		  "    x++, y++, z++, t++;",
		  "    int a = z - x + 1, b = t - y + 1;",
		  "    int lga = __lg(a);",
		  "    int lgb = __lg(b);",
		  "    num_t res = g[lgb][lga][y][x];",
		  "    res = best(res, g[lgb][lga][y + b - (1 << (lgb))][x + a - (1 << (lga))]);",
		  "    res = best(res, g[lgb][lga][y][x + a - (1 << (lga))]);",
		  "    res = best(res, g[lgb][lga][y + b - (1 << (lgb))][x]);",
		  "    return res;",
		  "  }",
		  "};",
		  "RMQ2D<int> rmq;"
		],
		"description": "RMQ2D"
	  },
	  "GridGenerator": {
		"prefix": "GridGenerator",
		"body": [
		  "namespace grid_iterator_ns {",
		  "const array<pair<int, int>, 8> dirs = {{{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {-1, -1}, {1, -1}, {-1, 1}}};",
		  "struct GridIterator {",
		  "    int n, m;",
		  "    GridIterator(int n, int m) : n(n), m(m) {}",
		  " ",
		  "    template<size_t N>",
		  "    struct NeighbourIteratorContainer {",
		  "        int i, j, n, m;",
		  "        NeighbourIteratorContainer(int i, int j, int n, int m) : i(i), j(j), n(n), m(m) {}",
		  " ",
		  "        struct NeighbourIterator {",
		  "            int cur;",
		  "            int i, j, n, m;",
		  "            NeighbourIterator(int cur, int i, int j, int n, int m) : cur(cur), i(i), j(j), n(n), m(m) {",
		  "                skip_to_first_allowed();",
		  "            }",
		  " ",
		  "            void skip_to_first_allowed() {",
		  "                while (cur < N &&",
		  "                    (i + dirs[cur].first  < 0 || i + dirs[cur].first  >= n ||",
		  "                     j + dirs[cur].second < 0 || j + dirs[cur].second >= m)) {",
		  "                    ++cur;",
		  "                }",
		  "            }",
		  " ",
		  "            NeighbourIterator& operator ++ () {",
		  "                ++cur;",
		  "                skip_to_first_allowed();",
		  "                return *this;",
		  "            }",
		  " ",
		  "            pair<int, int> operator * () const { return {i + dirs[cur].first, j + dirs[cur].second}; }",
		  " ",
		  "            bool operator == (const NeighbourIterator& other) const { return cur == other.cur; }",
		  "        };",
		  " ",
		  "        auto begin() const { return NeighbourIterator(0, i, j, n, m); }",
		  "        auto end()   const { return NeighbourIterator(N, i, j, n, m); }",
		  " ",
		  "        auto collect() const {",
		  "            vector<pair<int, int>> result;",
		  "            for (auto it = begin(); it != end(); ++it) result.push_back(*it);",
		  "            return result;",
		  "        }",
		  "    };",
		  " ",
		  "    template<size_t N>",
		  "    auto iterate(int i, int j) const {",
		  "        static_assert(N == 4 || N == 8, \"you can remove this, but make sure you understand what you are doing\");",
		  "        return NeighbourIteratorContainer<N>(i, j, n, m);",
		  "    }",
		  "};",
		  "}",
		  "using grid_iterator_ns::GridIterator;"
		],
		"description": "GridGenerator"
	  },
	  "BCC": {
		"prefix": "BCC",
		"body": [
		  "namespace BCC {",
		  "    int timer;",
		  "    vector<int> num;",
		  "    vector<int> low;",
		  "    vector<int> art;",
		  "    vector<pair<int, int>> bridges;",
		  "    vector<vector<int>> comps;",
		  "    vector<int> stk;",
		  "",
		  "    void _dfs(const vector<vector<int>> &adj, int u, int p = -1) {",
		  "        num[u] = low[u] = ++timer;",
		  "        stk.push_back(u);",
		  "        for (int v : adj[u]) {",
		  "            if (!num[v]) {",
		  "            _dfs(adj, v, u);",
		  "            if (low[v] > num[u]) {",
		  "                bridges.push_back({u, v});",
		  "            }",
		  "            low[u] = min(low[u], low[v]);",
		  "            if (low[v] >= num[u]) {",
		  "                art[u] = num[u] > 1 || num[v] > 2;",
		  "                vector<int> comp = {u};",
		  "                comps.push_back(comp);",
		  "                while (comps.back().back() != v) {",
		  "                comps.back().push_back(stk.back()), stk.pop_back();",
		  "                }",
		  "            }",
		  "            } else if (v != p) {",
		  "            low[u] = min(low[u], num[v]);",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    tuple<vector<vector<int>>, vector<int>, vector<pair<int, int>>> build(const vector<vector<int>> &adj, int rt = 0) {",
		  "        int n = adj.size();",
		  "        timer = 0;",
		  "        num = vector<int>(n);",
		  "        low = vector<int>(n);",
		  "        art = vector<int>(n);",
		  "        bridges.clear();",
		  "        comps.clear();",
		  "        stk.clear();",
		  "        _dfs(adj, rt);",
		  "        return {comps, art, bridges};",
		  "    }",
		  "} // namespace BCC"
		],
		"description": "BCC"
	  },
	  "PersistentFenwick": {
		"prefix": "PersistentFenwick",
		"body": [
		  "// NOTE:",
		  "// - 0-based index",
		  "// - for updates: time must be in increasing order",
		  "// - Update: O(log), Get: O(log^2)",
		  "//",
		  "// Partially Persistent FenwickTree {{{",
		  "template<",
		  "    typename T  // need to support operators + - <",
		  "> struct PartiallyPersistentFenwick {",
		  "    PartiallyPersistentFenwick(int _n) : n(_n), f(_n + 1) {",
		  "        for (int i = 0; i <= n; ++i) {",
		  "            f[i].emplace_back(INT_MIN, T{});",
		  "        }",
		  "    }",
		  "",
		  "    // a[u] += val",
		  "    void update(int time, int u, T val) {",
		  "        assert(0 <= u && u < n);",
		  "        assert(last_updated_time <= time);",
		  "        last_updated_time = time;",
		  "        ++u;",
		  "        for (; u <= n; u += u & -u) {",
		  "            f[u].emplace_back(time, f[u].back().second + val);",
		  "        }",
		  "    }",
		  "",
		  "    // return a[0] + .. + a[u-1]",
		  "    T get(int time, int u) const {",
		  "        assert(0 <= u && u <= n);",
		  "        T res{};",
		  "        for (; u > 0; u -= u & -u) {",
		  "            auto it = lower_bound(f[u].begin(), f[u].end(), make_pair(time+1, T{}));",
		  "            res = res + prev(it)->second;",
		  "        }",
		  "        return res;",
		  "    }",
		  "",
		  "    // return a[l] + .. + a[r-1]",
		  "    T get(int time, int l, int r) const {",
		  "        assert(0 <= l && l <= r && r <= n);",
		  "        if (l == r) return T{};  // empty",
		  "        return get(time, r) - get(time, l);",
		  "    }",
		  "",
		  "    int n;",
		  "    int last_updated_time = INT_MIN;",
		  "    vector<vector<pair<int, T>>> f;  // (time, data)",
		  "};"
		],
		"description": "PersistentFenwick"
	  },
	  "Fenwick2D": {
		"prefix": "Fenwick2D",
		"body": [
		  "template <typename num_t> struct RangeFenwick2D {",
		  "  int n, m;",
		  "  vector<vector<num_t>> fen[4];",
		  "",
		  "  RangeFenwick2D(int n, int m) {",
		  "    this->n = n, this->m = m;",
		  "    for (int i = 0; i < 4; i++) {",
		  "      fen[i].resize(n + 1, vector<num_t>(m + 1));",
		  "    }",
		  "  }",
		  "  void upd(int x, int y, num_t val) {",
		  "    x++, y++;",
		  "    assert(0 < x && 0 < y);",
		  "    for (int xx = x; xx <= n; xx += xx & -xx) {",
		  "      for (int yy = y; yy <= m; yy += yy & -yy) {",
		  "        fen[0][xx][yy] += val;",
		  "        fen[1][xx][yy] += x * val;",
		  "        fen[2][xx][yy] += y * val;",
		  "        fen[3][xx][yy] += x * y * val;",
		  "      }",
		  "    }",
		  "  }",
		  "  void upd(int x, int y, int z, int t, num_t val) {",
		  "    upd(x, y, +val);",
		  "    upd(x, t + 1, -val);",
		  "    upd(z + 1, y, -val);",
		  "    upd(z + 1, t + 1, +val);",
		  "  }",
		  "  num_t query(int x, int y) {",
		  "    x++, y++;",
		  "    assert(x <= n && y <= m);",
		  "    num_t res = 0;",
		  "    for (int xx = x; xx > 0; xx -= xx & -xx) {",
		  "      for (int yy = y; yy > 0; yy -= yy & -yy) {",
		  "        res += (x + 1) * (y + 1) * fen[0][xx][yy];",
		  "        res -= (y + 1) * fen[1][xx][yy];",
		  "        res -= (x + 1) * fen[2][xx][yy];",
		  "        res += fen[3][xx][yy];",
		  "      }",
		  "    }",
		  "    return res;",
		  "  }",
		  "  num_t query(int x, int y, int z, int t) {",
		  "    return query(z, t) - query(x - 1, t) - query(z, y - 1) +",
		  "           query(x - 1, y - 1);",
		  "  }",
		  "};"
		],
		"description": "Fenwick2D"
	  },
    "DirectedDFS": {
      "prefix": "DirectedDFS",
      "body": [
        "struct DirectedDfs {",
        "    vector<vector<int>> g;",
        "    int n;",
        "    vector<int> num, low, current, S;",
        "    int counter;",
        "    vector<int> comp_ids;",
        "    vector< vector<int> > scc;",
        "",
        "    DirectedDfs(const vector<vector<int>>& _g) : g(_g), n(g.size()),",
        "            num(n, -1), low(n, 0), current(n, 0), counter(0), comp_ids(n, -1) {",
        "        for (int i = 0; i < n; i++) {",
        "            if (num[i] == -1) dfs(i);",
        "        }",
        "    }",
        "",
        "    void dfs(int u) {",
        "        low[u] = num[u] = counter++;",
        "        S.push_back(u);",
        "        current[u] = 1;",
        "        for (auto v : g[u]) {",
        "            if (num[v] == -1) dfs(v);",
        "            if (current[v]) low[u] = min(low[u], low[v]);",
        "        }",
        "        if (low[u] == num[u]) {",
        "            scc.push_back(vector<int>());",
        "            while (1) {",
        "                int v = S.back(); S.pop_back(); current[v] = 0;",
        "                scc.back().push_back(v);",
        "                comp_ids[v] = ((int) scc.size()) - 1;",
        "                if (u == v) break;",
        "            }",
        "        }",
        "    }",
        "",
        "    // build DAG of strongly connected components",
        "    // Returns: adjacency list of DAG",
        "    std::vector<std::vector<int>> build_scc_dag() {",
        "        std::vector<std::vector<int>> dag(scc.size());",
        "        for (int u = 0; u < n; u++) {",
        "            int x = comp_ids[u];",
        "            for (int v : g[u]) {",
        "                int y = comp_ids[v];",
        "                if (x != y) {",
        "                    dag[x].push_back(y);",
        "                }",
        "            }",
        "        }",
        "        return dag;",
        "    }",
        "};"
      ],
      "description": "DirectedDFS"
    },
	"Compress": {
		"prefix": "Compress",
		"body": [
		  "template<typename T>",
		  "struct Compress{",
		  "    vector<int> mp;",
		  "    map<T, int> idx;",
		  "    Compress(vector<T>& arr){",
		  "        int n = arr.size();",
		  "        vector<pair<T, int>> pairs;",
		  "        mp = vector<int>(n);",
		  "        for(int i = 0; i < n; ++i){",
		  "            pairs.push_back({arr[i], i});",
		  "        }",
		  "        sort(pairs.begin(), pairs.end());",
		  "        int nxt = 0;",
		  "        for(int i = 0; i < n; ++i){",
		  "            if(i > 0 && pairs[i - 1].first != pairs[i].first) ++nxt;",
		  "            mp[nxt] = pairs[i].first;",
		  "            idx[pairs[i].first] = nxt;",
		  "            arr[pairs[i].second] = nxt;",
		  "        }",
		  "    }",
		  "};"
		],
		"description": "Compress"
	  },
	  "int128": {
		"prefix": "int128",
		"body": [
		  "using i128 = __int128_t;",
		  "i128 str2i128(std::string str) {",
		  "    i128 ret = 0;",
		  "    bool minus = false;",
		  "    for (auto c : str) {",
		  "        if (c == '-')",
		  "            minus = true;",
		  "        else",
		  "            ret = ret * 10 + c - '0';",
		  "    }",
		  "    return minus ? -ret : ret;",
		  "}",
		  "std::istream &operator>>(std::istream &is, i128 &x) {",
		  "    std::string s;",
		  "    return is >> s, x = str2i128(s), is;",
		  "}",
		  "std::ostream &operator<<(std::ostream &os, const i128 &x) {",
		  "    i128 tmp = x;",
		  "    if (tmp == 0) return os << 0;",
		  "    std::vector<int> ds;",
		  "    if (tmp < 0) {",
		  "        os << '-';",
		  "        while (tmp) {",
		  "            int d = tmp % 10;",
		  "            if (d > 0) d -= 10;",
		  "            ds.emplace_back(-d), tmp = (tmp - d) / 10;",
		  "        }",
		  "    } else {",
		  "        while (tmp) ds.emplace_back(tmp % 10), tmp /= 10;",
		  "    }",
		  "    std::reverse(ds.begin(), ds.end());",
		  "    for (auto i : ds) os << i;",
		  "    return os;",
		  "}",
		  "i128 my_abs(i128 n) {",
		  "    if (n < 0) return -n;",
		  "    return n;",
		  "}",
		  "i128 gcd(i128 a, i128 b) {",
		  "    if (b == 0) return a;",
		  "    return gcd(b, a % b);",
		  "}",
		  "// Count trailing zeroes",
		  "int ctz128(i128 n) {",
		  "    if (!n) return 128;",
		  " ",
		  "    if (!static_cast<uint64_t>(n)) {",
		  "        return __builtin_ctzll(static_cast<uint64_t>(n >> 64)) + 64;",
		  "    } else {",
		  "        return __builtin_ctzll(static_cast<uint64_t>(n));",
		  "    }",
		  "}"
		],
		"description": "int128"
	  },
	  "nearest": {
		"prefix": "nearest",
		"body": [
		  "vector<int> leftNearestSmaller(const vector<int>& a) {",
		  "    int n = a.size();",
		  "    vector<int> left(n);",
		  "    stack<int> st;  // positions of candidates, A is increasing",
		  "    st.push(-1);",
		  "    for (int i = 0; i < n; i++) {",
		  "        while (st.top() >= 0 && a[st.top()] >= a[i]) st.pop();",
		  "        left[i] = st.top();",
		  "        st.push(i);",
		  "    }",
		  "    return left;",
		  "}",
		  "",
		  "// return:",
		  "// - right[i] = smallest j such that:",
		  "//      j > i",
		  "//      a[j] < a[i]",
		  "// - no such j -> right[i] = n",
		  "vector<int> rightNearestSmaller(const vector<int>& a) {",
		  "    int n = a.size();",
		  "    vector<int> right(n);",
		  "    stack<int> st;   // positions of candidates, A is increasing",
		  "    st.push(n);",
		  "    for (int i = n-1; i >= 0; i--) {",
		  "        while (st.top() < n && a[st.top()] >= a[i]) st.pop();",
		  "        right[i] = st.top();",
		  "        st.push(i);",
		  "    }",
		  "    return right;",
		  "}"
		],
		"description": "nearest"
	  },
	  "Mex": {
		"prefix": "Mex",
		"body": [
		  "template<typename T>",
		  "struct Mex {",
		  "private:",
		  "    map<T, int> frequency;",
		  "    set<T> missing_numbers;",
		  "    vector<T> A;",
		  "",
		  "public:",
		  "    Mex(vector<T> const& A) : A(A) {",
		  "        for (int i = 0; i <= A.size(); i++)",
		  "            missing_numbers.insert(i);",
		  "",
		  "        for (T x : A) {",
		  "            ++frequency[x];",
		  "            missing_numbers.erase(x);",
		  "        }",
		  "    }",
		  "",
		  "    T mex() {",
		  "        return *missing_numbers.begin();",
		  "    }",
		  "",
		  "    void update(int idx, T new_value) {",
		  "        if (--frequency[A[idx]] == 0)",
		  "            missing_numbers.insert(A[idx]);",
		  "        A[idx] = new_value;",
		  "        ++frequency[new_value];",
		  "        missing_numbers.erase(new_value);",
		  "    }",
		  "};"
		],
		"description": "Mex"
	  }
}
